#include <SPI.h>
#include <Wire.h>
#include <SoftwareSerial.h>
#include <HTTPClient.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#include <Fonts/FreeSerif12pt7b.h>
#include <Fonts/FreeSansBold12pt7b.h>
#include <Fonts/FreeMonoOblique12pt7b.h>
#include <Fonts/FreeMonoBold12pt7b.h>
#include <Fonts/FreeSerifBoldItalic9pt7b.h>
#include <Fonts/FreeSansOblique12pt7b.h>
#include <TinyGPS++.h>
#include <DHT.h>
#include "RtcDS3231.h"
#include "FS.h"
#include "SD.h"
#include <math.h>
#include "painlessMesh.h"
#include <Adafruit_Sensor.h>
#include "Fonts/FreeSans12pt7b.h"
#include <Arduino.h>
#include "AzureIotHub.h"
#include "Esp32MQTTClient.h"
#include "Sensirion_GadgetBle_Lib.h"
#include <WiFi.h>
#include <WiFiMulti.h>
#include "Adafruit_PM25AQI.h"
#include "SPI.h"
#include "RTClib.h"

SPIClass spi(HSPI);
/*Se inicializan las siguientes variables para respedctivamente 
- Enviar los datos a la aplicación de Sensririon 
- Tener redundancia en la conexión WiFi definiendo varios puntos de acceso, asegurando el envio de datos del dispositivo
- Capturar los datos (Particulas por millon) del sensor pmS5003
*/
const char* azureIoTHubConnectionString="iothubesp32makers.azure-devices.net";
const char* endpoint = "devices/DEVICE_TTGOV1.3";
WiFiServer server(80);
SoftwareSerial pmsSerial(32,25);
RTC_DS3231 rtc;

// Created with openssl s_client -showcerts -connect thingpulse.azure-devices.net:443
// and by picking the root certificate
const char* root_ca= \ 
"-----BEGIN CERTIFICATE-----\n" \
"MIIEtjCCA56gAwIBAgIQCv1eRG9c89YADp5Gwibf9jANBgkqhkiG9w0BAQsFADBh\n" \
"MQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3\n" \
"d3cuZGlnaWNlcnQuY29tMSAwHgYDVQQDExdEaWdpQ2VydCBHbG9iYWwgUm9vdCBH\n" \
"MjAeFw0yMjA0MjgwMDAwMDBaFw0zMjA0MjcyMzU5NTlaMEcxCzAJBgNVBAYTAlVT\n" \
"MR4wHAYDVQQKExVNaWNyb3NvZnQgQ29ycG9yYXRpb24xGDAWBgNVBAMTD01TRlQg\n" \
"UlMyNTYgQ0EtMTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAMiJV34o\n" \
"eVNHI0mZGh1Rj9mdde3zSY7IhQNqAmRaTzOeRye8QsfhYFXSiMW25JddlcqaqGJ9\n" \
"GEMcJPWBIBIEdNVYl1bB5KQOl+3m68p59Pu7npC74lJRY8F+p8PLKZAJjSkDD9Ex\n" \
"mjHBlPcRrasgflPom3D0XB++nB1y+WLn+cB7DWLoj6qZSUDyWwnEDkkjfKee6ybx\n" \
"SAXq7oORPe9o2BKfgi7dTKlOd7eKhotw96yIgMx7yigE3Q3ARS8m+BOFZ/mx150g\n" \
"dKFfMcDNvSkCpxjVWnk//icrrmmEsn2xJbEuDCvtoSNvGIuCXxqhTM352HGfO2JK\n" \
"AF/Kjf5OrPn2QpECAwEAAaOCAYIwggF+MBIGA1UdEwEB/wQIMAYBAf8CAQAwHQYD\n" \
"VR0OBBYEFAyBfpQ5X8d3on8XFnk46DWWjn+UMB8GA1UdIwQYMBaAFE4iVCAYlebj\n" \
"buYP+vq5Eu0GF485MA4GA1UdDwEB/wQEAwIBhjAdBgNVHSUEFjAUBggrBgEFBQcD\n" \
"AQYIKwYBBQUHAwIwdgYIKwYBBQUHAQEEajBoMCQGCCsGAQUFBzABhhhodHRwOi8v\n" \
"b2NzcC5kaWdpY2VydC5jb20wQAYIKwYBBQUHMAKGNGh0dHA6Ly9jYWNlcnRzLmRp\n" \
"Z2ljZXJ0LmNvbS9EaWdpQ2VydEdsb2JhbFJvb3RHMi5jcnQwQgYDVR0fBDswOTA3\n" \
"oDWgM4YxaHR0cDovL2NybDMuZGlnaWNlcnQuY29tL0RpZ2lDZXJ0R2xvYmFsUm9v\n" \
"dEcyLmNybDA9BgNVHSAENjA0MAsGCWCGSAGG/WwCATAHBgVngQwBATAIBgZngQwB\n" \
"AgEwCAYGZ4EMAQICMAgGBmeBDAECAzANBgkqhkiG9w0BAQsFAAOCAQEAdYWmf+AB\n" \
"klEQShTbhGPQmH1c9BfnEgUFMJsNpzo9dvRj1Uek+L9WfI3kBQn97oUtf25BQsfc\n" \
"kIIvTlE3WhA2Cg2yWLTVjH0Ny03dGsqoFYIypnuAwhOWUPHAu++vaUMcPUTUpQCb\n" \
"eC1h4YW4CCSTYN37D2Q555wxnni0elPj9O0pymWS8gZnsfoKjvoYi/qDPZw1/TSR\n" \
"penOgI6XjmlmPLBrk4LIw7P7PPg4uXUpCzzeybvARG/NIIkFv1eRYIbDF+bIkZbJ\n" \
"QFdB9BjjlA4ukAg2YkOyCiB8eXTBi2APaceh3+uBLIgLk8ysy52g2U3gP7Q26Jlg\n" \
"q/xKzj3O9hFh/g==\n" \
"-----END CERTIFICATE-----\n" \
"---";
WiFiClientSecure client;

GadgetBle gadgetBle = GadgetBle(GadgetBle::DataType::T_RH_CO2);
WiFiMulti WiFiMulti;
Adafruit_PM25AQI aqi = Adafruit_PM25AQI();

/*Se definen los pines  GPIO de la ESP TTGO V1.3 que estan siendo utilizados 
por los sensores para el envio de información

*/

#define CS_PIN 5              //Pin que permite habilitar o desahbilitar la comunicación desde la SD hacia el microcontrolador
#define DHTPIN 27             //Pin al que está conectado el sensor DHT
#define DHTTYPE DHT11         //Tipo de sensor DHT
#define OLED_ADDRESS 0x3C     //El microcontrolador se comunicará con la pantalla a traves de esta dirección
#define SCREEN_WIDTH 128      //Ancho del display - Dimensiones de acuerdo al display utilizado
#define SCREEN_HEIGHT 64      //Alto del display - Dimensiones de acuerdo al display utilizado
#define RXD2 16               //Pin de recepción que permite la comunicación serial con el módulo GPS
#define TXD2 17               //Pin de transmisión que permite la comunicación serial con el módulo GPS
HardwareSerial neogps(2);     //Se instancia de la clase HardwareSerial para comunicación serial a través de un puerto específicoo con el módulo GPS.
char datoCmd = 0;             //¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡
#define NMEA 0                //
#define I2C_ADDR 0x27        //Especificar la dirección del dispositivo necesaria para comunicarse en el bus I2C
TinyGPSPlus gps;             //
#define MESH_PREFIX "RED_USA_2023"//Prefijo utilizado para la configuración y conectividad de los dipositivos en la red mesh
#define MESH_PASSWORD "USA123*."  //Contraseña para aprobar el acceso de cada dispositivo conectado a la red en malla 
#define MESH_PORT 5555            //Puerto de comunicación 
#define INTERVAL 3000             //¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡
#define DEVICE_ID "ESP32Device"   //Id del dispositivo que permitirá identificar los mensajes enviados por cada dispositivo
#define MESSAGE_MAX_LEN 256       //El Maximo tamaño de la data que se enviará a la nube debe ser de 256 bytes


// Se establece el nombre de la SSID y la contraseña en caso de que la red donde vamos a conectar el dispositivo utilice protocolos de red WPA y WPA2.
const char* ssid     = "FIBRA_MOVISTAR_SMART_0822";
const char* password = "EAVJ500#*";
//Variable que hace un conteo del numero de mensajes cargados a la nube de Azure
int messageCount = 1;    
//Cadena de conexión unica proporcionada durante la creación del dispositivo IOT en la interfaz de Azure (Dirección del servidor,ID unico del dispositivo,Clave para el acceso)
static const char* connectionString = "HostName=iothubesp32makers.azure-devices.net;DeviceId=DEVICE_TTGOV1.3;SharedAccessKey=SmlaYFeXDKP0tuvWkw9eIeLTbNNy6njSaAIoTNbg90k=";
//Cadena en formato JSON con el nombre de cada variable y el formato especifico para cada tipo de dato medido por los sensores.
const char *messageData = "{\"deviceId\":\"%s\", \"messageId\":%d, \"Temperatura\":%f, \"Humedad\":%f, \"Fecha\":%c, \"Hora\":%c, \"Satelites\":%u, \"Latitud\":%f, \"Longuitud\":%f, \"Velocidad\":%f  }"; //message format or the format template
static bool hasWifi = false;
static bool messageSending = true;
//Variable que permite obtener el tiempo desde que la ESP32 ejecutó el programa
static uint64_t send_interval_ms; 

//Se inicializa la variable que permite relacionar una tarea que se ejecuta de forma paralela de forma concurrente pero permitiendo la ejecución continua de las instrucciones
Scheduler userScheduler;
//Se inicializa la variable que permite la creación de una red en malla. 
painlessMesh mesh;

//Declaración de las funciones 
void data_DHT_11_display(float, float, float, float, float);
void receiveMessage();
void sendMessage();
void receivedCallback(uint32_t from, String& msg);
void newConnectionCallback(uint32_t nodeId);
void changedConnectionCallback();
void nodeTimeAdjustedCallback(int32_t offset);
void delayReceivedCallback(uint32_t from, int32_t delay);
bool menu_show_data();
bool menu();
void module_SD(int option);
void data_RTC_HW_084();
void menu_network();    //¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡
void sendMessage();
void send_data_PM2();
void wait_screen(long interval);    
void data_GPS_NEO6MV2();

// Se crea una tarea recurrente  para el envio de mensajes a los nodos conectados segun el intervalo de tiempo especificado
Task taskSendMessage(TASK_SECOND * 1, TASK_FOREVER, &sendMessage);
Task taskGetMessage(TASK_SECOND * 1, TASK_FOREVER, &receiveMessage);
//Creación de una instancia para la configuración inicial del sensor DHT. Arg: Pin de comunicación y el tipo de sensor segun el proposito del proyecto (DHT11: Temperatura y humedad)
DHT dht(DHTPIN, DHTTYPE);
//Se crea una instancia para utilizar los metodos que permite la obtención de los datos
RtcDS3231<TwoWire> Rtc(Wire);
//Se crea una instancia para visualizar y limpiar los datos en la pantalla del display
Adafruit_SSD1306 display = Adafruit_SSD1306(128, 64, &Wire, OLED_ADDRESS);

//Se inicializa o declara un conjunto de variables. Se especifica el tamaño del buffer o del array 
bool status_menu=false;   //Variable que toma dos valores para controlar la visibilidad del menu
int values_PM[]={0,0,0,0,0,0,0,0,0,0,0,0};  //Los valores que tomarán las medidas de PM10, PM2.5 y PM100 obtenidas con el sensor PMS5003 en caso de que no se detecte el sensor o se presenten problemas en la transmisión de información
char buffer_data[3][40];  //Matriz que permitirá almacenar las metricas obtenidas con el reloj DS3231
bool flag = false;        //Inicializar la variable que permita solamente el envio de la propia infromación del nodo a otros nodos circudante en el area
String data_send = "";    //Variable que permitirá concatenar todos las metricas y será el mensaje a adjuntar en el archivo de la sd
int num_satelites=0;      //¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡
float lat = 0;            // Se inicializa la variable que permitirá obtener la latitud segun las datos del GPS.
float lon = 0;            // Se inicializa la variable que permitirá obtener la longuitud segun las datos del GPS. 
float speed = 0;          // Se inicializa la variable que contendra el valor de la velocidad.
float H_T[] = {0,0};      // Se inicializa el arreglo que contiene los valores de temperatura y humedad en caso de fallar la comunicación con el sensor DHT11.
String buffer_pm =""; //Se inicializa un buffer que guarda un espacio de 50 bytes de la memoria de la ESP32 para almacenar los datos obtenidos por el sensor PMS5003
char file_name[150];      //Se inicializa el arreglo de caracteres que contendrá la ruta del archivo que tiene los valores de cada uno de los registros tomados por los sensores
//RtcDateTime now;          //Se declara la variable que registrará el valor de la hora y fecha actual que indicada por el reloj
const int NUM_BUFFERS = 5;   // Definir el número de buffers
const int BUFFER_SIZE = 32;  // Definir el tamaño de cada buffer
int option_menu = 0;         //¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡
int button[] = { 0, 0, 0 };  //¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡
char* buffer_dht = (char*)malloc(150); //Buffer con espacio de  de 150 bytes reservado en memoria que recopila los datos del sensor DHT11
char* buffer_rtc = (char*)malloc(150); //Buffer con espacio de  de 150 bytes reservado en memoria que recopila los datos del reloj RTC
char buffer_gps[4][50];                //Se declara una matriz de 4 filas para guardar un array de caracteres que almacena lt,lon,speed y num.satelites encontrados por el modulo GPS.
char* data_gps=(char*) malloc(50);     //Puntero char que inicializa cada posicion de la variable buffer_gps con valores de 0.0
char* buffer_final = (char*)malloc(200);// //¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡
unsigned long previousMillis = 0;      //Se inicializa una variable que registrará el tiempo transcurrido desde la puesta en ejecución del programa
char name_folder[100];                 //¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡
static int64_t lastMmntTime = 0;       //Se inicializa la variable que se le asignará un metodo que retornará una mayor precisión del espacio de tiempo desde el inicio del sistema
static int measurementIntervalMs = 1000; //Se declara esta variable que permite especificar un intervalo de tiempo para que nuevamente se transmita los datos por medio de bluethoot a la APP de Sensirion
int status = WL_IDLE_STATUS;      //¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡
bool isconnected=false;

/* 
  En las siguientes lineas se define los iconos que se utilizarán en la ejecucuión del programa.
  La imagen es un array constante de bytes que representan los pixeles. Este grupo de bytes son el resultado de subir una imagen a https://javl.github.io/image2cpp/, configurar tamaño, color y movimiento
*/



struct pms5003data {
  uint16_t framelen;
  uint16_t pm10_standard, pm25_standard, pm100_standard;
  uint16_t pm10_env, pm25_env, pm100_env;
  uint16_t particles_03um, particles_05um, particles_10um, particles_25um, particles_50um, particles_100um;
  uint16_t unused;
  uint16_t checksum;
};
 
struct pms5003data data;

const unsigned char logo_ste [] PROGMEM = {
	0x08, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00, 
	0xff, 0x00, 0x00, 0x00, 0x7f, 0x80, 0x00, 0x00, 0x3f, 0xc0, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 
	0x07, 0xf8, 0x00, 0x00, 0x03, 0xfc, 0x60, 0x00, 0x01, 0xfc, 0xf0, 0x00, 0x01, 0xf9, 0xf8, 0x00, 
	0x00, 0xff, 0xf8, 0x00, 0x10, 0x6f, 0xf0, 0x00, 0x00, 0x0f, 0xe0, 0x00, 0x20, 0x1f, 0xc0, 0x00, 
	0x20, 0x0f, 0xd8, 0x00, 0x00, 0x0f, 0xfc, 0x00, 0x00, 0x32, 0x7c, 0x00, 0x00, 0x30, 0xfe, 0x00, 
	0x00, 0x00, 0xff, 0x00, 0x20, 0x00, 0x7f, 0x80, 0x00, 0x00, 0x1f, 0xe0, 0x00, 0x00, 0x0f, 0xf0, 
	0x00, 0x00, 0x07, 0xf8, 0x00, 0x00, 0x03, 0xfc, 0x00, 0x00, 0x83, 0xf8, 0x00, 0x82, 0x01, 0xf0, 
	0x00, 0x00, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x40
};
const unsigned char blue[] PROGMEM={
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf3, 0xe0, 
	0x00, 0x00, 0x00, 0x00, 0x80, 0xf1, 0xe0, 0x00, 0x00, 0x00, 0x01, 0xe0, 0xf0, 0xf0, 0x00, 0x00, 
	0x00, 0x03, 0xe0, 0xf0, 0x78, 0x00, 0x00, 0x00, 0x01, 0xf0, 0xf0, 0x78, 0x00, 0x00, 0x00, 0x00, 
	0xf8, 0xf0, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x7e, 0xf1, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xfb, 
	0xe0, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0x80, 0x00, 
	0x00, 0x00, 0x00, 0x07, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xfe, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x01, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
	0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xc0, 0x00, 0x00, 
	0x00, 0x00, 0x3e, 0xf3, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x7c, 0xf1, 0xf0, 0x00, 0x00, 0x00, 0x01, 
	0xf8, 0xf0, 0xf8, 0x00, 0x00, 0x00, 0x01, 0xf0, 0xf0, 0x7c, 0x00, 0x00, 0x00, 0x03, 0xe0, 0xf0, 
	0xfc, 0x00, 0x00, 0x00, 0x01, 0xc0, 0x71, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x80, 0x73, 0xf0, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x7f, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xc0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x7f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x7e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

const unsigned char logo_satelite [] PROGMEM = {
	// 'satelite (1), 40x40px
	0xff, 0x9f, 0xff, 0xff, 0xff, 0xfe, 0x0f, 0xff, 0xff, 0xff, 0xf8, 0x0f, 0xff, 0xff, 0xff, 0xe0, 
	0x07, 0xff, 0xff, 0xff, 0x80, 0x03, 0xff, 0xff, 0xff, 0x00, 0x03, 0xff, 0xff, 0xff, 0x00, 0x01, 
	0xff, 0xff, 0xff, 0x80, 0x01, 0xff, 0xe3, 0xff, 0xc0, 0x00, 0xff, 0x81, 0xff, 0xe0, 0x00, 0xff, 
	0x80, 0xff, 0xf0, 0x00, 0x7f, 0xc0, 0x7f, 0xf8, 0x00, 0x3c, 0xe0, 0x7f, 0xfc, 0x00, 0x38, 0x70, 
	0x7f, 0xfe, 0x00, 0x70, 0x38, 0xff, 0xff, 0x00, 0xe0, 0x1d, 0xff, 0xff, 0x80, 0x40, 0x0f, 0xff, 
	0xff, 0xc2, 0x00, 0x07, 0xff, 0xff, 0xe7, 0x00, 0x0f, 0xff, 0xff, 0xff, 0x00, 0x1f, 0xff, 0xff, 
	0xff, 0x00, 0x3f, 0xff, 0xff, 0xe1, 0x00, 0x3f, 0xff, 0xff, 0x80, 0x00, 0xff, 0xff, 0xff, 0x00, 
	0x00, 0xe7, 0xff, 0xff, 0x00, 0x00, 0x43, 0xff, 0xff, 0x80, 0x1e, 0x00, 0xff, 0xff, 0xc0, 0x1f, 
	0x00, 0x3f, 0xff, 0xe0, 0x0e, 0x00, 0x0f, 0xbd, 0xe0, 0x0c, 0x00, 0x07, 0x39, 0xc0, 0x1c, 0x00, 
	0x01, 0x38, 0xec, 0x1e, 0x00, 0x00, 0x18, 0xfe, 0x1f, 0x00, 0x00, 0x1c, 0x7f, 0x3f, 0x80, 0x01, 
	0x9e, 0x0f, 0xff, 0xc0, 0x01, 0x8f, 0x0f, 0xff, 0xe0, 0x03, 0xc7, 0xcf, 0xff, 0xf0, 0x03, 0xc3, 
	0xff, 0xff, 0xf8, 0x07, 0xe1, 0xff, 0xff, 0xfc, 0x07, 0xf0, 0x1f, 0xff, 0xfe, 0x0f, 0xfc, 0x0f, 
	0xff, 0xff, 0x0f, 0xff, 0x8f, 0xff, 0xff, 0x9f
};

const unsigned char Sensirion_Logo [] PROGMEM = {
	// 'bluetooth, 50x50px
	0xff, 0xff, 0xf0, 0x03, 0xff, 0xff, 0xc0, 0xff, 0xff, 0x80, 0x00, 0x7f, 0xff, 0xc0, 0xff, 0xfc, 
	0x00, 0x00, 0x0f, 0xff, 0xc0, 0xff, 0xf0, 0x00, 0x00, 0x03, 0xff, 0xc0, 0xff, 0xe0, 0x00, 0x00, 
	0x01, 0xff, 0xc0, 0xff, 0x80, 0x00, 0x00, 0x00, 0x7f, 0xc0, 0xff, 0x00, 0x00, 0xc0, 0x00, 0x3f, 
	0xc0, 0xfe, 0x00, 0x00, 0xe0, 0x00, 0x1f, 0xc0, 0xfc, 0x00, 0x00, 0xf0, 0x00, 0x0f, 0xc0, 0xf8, 
	0x00, 0x00, 0xfc, 0x00, 0x07, 0xc0, 0xf8, 0x00, 0x00, 0xfe, 0x00, 0x07, 0xc0, 0xf0, 0x00, 0x00, 
	0xff, 0x00, 0x03, 0xc0, 0xe0, 0x00, 0x00, 0xe7, 0x80, 0x01, 0xc0, 0xe0, 0x00, 0x00, 0xe3, 0xc0, 
	0x01, 0xc0, 0xc0, 0x00, 0x00, 0xe1, 0xe0, 0x00, 0xc0, 0xc0, 0x03, 0x00, 0xe0, 0xf8, 0x00, 0xc0, 
	0xc0, 0x07, 0x80, 0xe0, 0x78, 0x00, 0xc0, 0x80, 0x03, 0xe0, 0xe1, 0xf0, 0x00, 0x40, 0x80, 0x01, 
	0xf0, 0xe3, 0xe0, 0x00, 0x40, 0x80, 0x00, 0xf8, 0xe7, 0xc0, 0x00, 0x40, 0x00, 0x00, 0x3c, 0xef, 
	0x80, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xfc, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x07, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x03, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 
	0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0xef, 0x00, 
	0x00, 0x00, 0x80, 0x00, 0xf8, 0xe7, 0xc0, 0x00, 0x40, 0x80, 0x01, 0xf0, 0xe3, 0xe0, 0x00, 0x40, 
	0x80, 0x03, 0xe0, 0xe1, 0xf0, 0x00, 0x40, 0xc0, 0x07, 0x80, 0xe0, 0x78, 0x00, 0xc0, 0xc0, 0x03, 
	0x00, 0xe0, 0xf8, 0x00, 0xc0, 0xc0, 0x00, 0x00, 0xe1, 0xe0, 0x00, 0xc0, 0xe0, 0x00, 0x00, 0xe3, 
	0xc0, 0x01, 0xc0, 0xe0, 0x00, 0x00, 0xe7, 0x80, 0x01, 0xc0, 0xf0, 0x00, 0x00, 0xff, 0x00, 0x03, 
	0xc0, 0xf8, 0x00, 0x00, 0xfe, 0x00, 0x07, 0xc0, 0xf8, 0x00, 0x00, 0xfc, 0x00, 0x07, 0xc0, 0xfc, 
	0x00, 0x00, 0xf8, 0x00, 0x0f, 0xc0, 0xfe, 0x00, 0x00, 0xe0, 0x00, 0x1f, 0xc0, 0xff, 0x00, 0x00, 
	0xc0, 0x00, 0x3f, 0xc0, 0xff, 0x80, 0x00, 0x00, 0x00, 0x7f, 0xc0, 0xff, 0xe0, 0x00, 0x00, 0x01, 
	0xff, 0xc0, 0xff, 0xf0, 0x00, 0x00, 0x03, 0xff, 0xc0, 0xff, 0xfc, 0x00, 0x00, 0x0f, 0xff, 0xc0, 
	0xff, 0xff, 0x80, 0x00, 0x7f, 0xff, 0xc0, 0xff, 0xff, 0xf0, 0x03, 0xff, 0xff, 0xc0
};

const unsigned char UniversidadSergioArboleda[] PROGMEM = {
  // 'frame_00_delay-0, 50x50px
  // 'frame_00_delay-0, 50x50px
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xe0, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xc0, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xcd, 0xd2, 0x56, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xcd, 0xd2, 0x56, 0xff, 0xff, 0xee, 0x8d, 0x87, 0x40, 0x83, 0x66, 0xc3, 0xe7, 0x0f, 0xff, 0xff,
  0xcd, 0xd2, 0x56, 0xff, 0xff, 0xce, 0x85, 0xa7, 0x4f, 0xbb, 0x76, 0xdd, 0xd7, 0x73, 0xff, 0xff,
  0xcd, 0xd0, 0x56, 0xff, 0xff, 0xde, 0x91, 0xb6, 0x4d, 0xbb, 0x3e, 0xde, 0xd7, 0x7b, 0xff, 0xff,
  0xc9, 0x92, 0xd6, 0xff, 0xff, 0xde, 0x99, 0xb2, 0xcd, 0x87, 0x8e, 0xde, 0xd3, 0x79, 0xff, 0xff,
  0xca, 0xd2, 0xd6, 0xff, 0xff, 0x9e, 0x9d, 0xb8, 0xcf, 0xb7, 0xf6, 0xde, 0xfb, 0x79, 0xff, 0xff,
  0xca, 0xd2, 0xd6, 0xff, 0xff, 0xce, 0x9d, 0xb9, 0xcf, 0xb2, 0xf6, 0xde, 0xbb, 0x7b, 0xff, 0xff,
  0xca, 0xd2, 0xcc, 0xff, 0xff, 0xe0, 0x9d, 0xb9, 0xce, 0xbb, 0x66, 0xd9, 0xb9, 0x67, 0xff, 0xff,
  0xcc, 0xd2, 0x5c, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xc6, 0x11, 0xda, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xc2, 0x43, 0xc2, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xc8, 0x71, 0xfe, 0xf6, 0xce, 0xb3, 0xb3, 0x76, 0xfe, 0x73, 0x66, 0xf6, 0x67, 0x9d, 0x67, 0x9f,
  0xcf, 0x03, 0xfe, 0xe6, 0xcf, 0xbb, 0x77, 0x6f, 0x7e, 0x7b, 0x37, 0x6f, 0x67, 0x9f, 0x73, 0x9f,
  0xcf, 0xf3, 0xfe, 0xf3, 0xc1, 0xbb, 0x7f, 0x6f, 0x3d, 0xbb, 0x36, 0xef, 0xa7, 0x83, 0x79, 0x6f,
  0xcf, 0xf3, 0xfe, 0xfc, 0xcf, 0xa7, 0x7b, 0x6f, 0xbd, 0x3a, 0x76, 0xef, 0xa7, 0x9f, 0x79, 0x4f,
  0xcf, 0xf3, 0xfe, 0xfe, 0x4f, 0xb7, 0x7b, 0x6f, 0x7f, 0x9b, 0x77, 0x6f, 0x27, 0x9f, 0x79, 0xe7,
  0xe7, 0xf3, 0xf9, 0xee, 0x4f, 0xbb, 0x3b, 0x6f, 0x7f, 0x9b, 0x77, 0x67, 0x67, 0x9d, 0x72, 0xe7,
  0xf3, 0xf3, 0xf3, 0xf0, 0xe1, 0xbb, 0xc3, 0x70, 0xfb, 0xdb, 0xb0, 0x70, 0xe0, 0xc1, 0x06, 0xf7,
  0xfc, 0x73, 0x8f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0x13, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xc0, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xf3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};
const unsigned char message_icon[] PROGMEM = {
  // 'enviar-correo, 25x25px
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0x80, 0x01, 0x80, 0x00, 0x80,
  0x3d, 0xc0, 0x00, 0x80, 0x01, 0x20, 0x04, 0x80, 0x00, 0x18, 0x08, 0x80, 0xff, 0xcc, 0x10, 0x80,
  0x01, 0x0e, 0x70, 0x80, 0x01, 0x1b, 0xd0, 0x80, 0x0f, 0x31, 0x88, 0x80, 0x01, 0x60, 0x04, 0x80,
  0xf1, 0xc0, 0x03, 0x80, 0x01, 0x80, 0x01, 0x80, 0x01, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00
};
const unsigned char logo[] PROGMEM = {
  0xff, 0x9f, 0xf0, 0xff, 0x9f, 0xf0, 0xee, 0x07, 0x70, 0xc0, 0x00, 0x30, 0xe0, 0xf0, 0x70, 0xe3,
  0xfc, 0x70, 0xe7, 0xce, 0x70, 0xc7, 0xe7, 0x30, 0xcf, 0xe3, 0x30, 0x0d, 0xe3, 0x00, 0x0c, 0xe3,
  0x00, 0x8c, 0x03, 0xb0, 0xc6, 0x01, 0xf0, 0xe7, 0x00, 0xf0, 0xe3, 0xf0, 0x70, 0xe1, 0xf8, 0x30,
  0xc0, 0x0c, 0x10, 0xee, 0x0e, 0x00, 0xff, 0x0f, 0x00, 0xff, 0x9f, 0x90

};

const unsigned char icon_hot[] PROGMEM = {
  0xff, 0xef, 0xf0, 0xff, 0xc7, 0xf0, 0xff, 0x87, 0xf0, 0xff, 0x87, 0xf0, 0xff, 0x03, 0xf0, 0xff,
  0x01, 0xf0, 0xff, 0x00, 0xf0, 0xf3, 0x00, 0xf0, 0xe3, 0x00, 0x70, 0xe0, 0x00, 0x70, 0xe0, 0x00,
  0x70, 0xe0, 0x00, 0x70, 0xe0, 0x00, 0x70, 0xe0, 0x20, 0x70, 0xe0, 0x30, 0x70, 0xe0, 0x70, 0x70,
  0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xfc, 0xf1, 0xf0, 0xfe, 0x07, 0xf0
};

byte grados[8] = { 0b00110, 0b01001, 0b01001, 0b00110, 0b00000, 0b00000, 0b00000, 0b00000 };

const unsigned char location[] PROGMEM = {
  0xff, 0x0f, 0xf0, 0xfc, 0x03, 0xf0, 0xf8, 0x01, 0xf0, 0xf0, 0x00, 0xf0, 0xf0, 0xf0, 0xf0, 0xf1,
  0xf8, 0xf0, 0xf1, 0xf8, 0xf0, 0xf1, 0xf8, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0x00, 0xf0, 0xf8, 0x01,
  0xf0, 0xfc, 0x03, 0xf0, 0xfc, 0x03, 0xf0, 0xfe, 0x07, 0xf0, 0xe3, 0x0c, 0x70, 0xc1, 0x08, 0x30,
  0x81, 0x98, 0x10, 0xc0, 0x90, 0x30, 0xe0, 0x60, 0x70, 0xf8, 0x01, 0xf0
};

const unsigned char icon_humedity[] PROGMEM = {
  0xff, 0x9f, 0xf0, 0xff, 0x9f, 0xf0, 0xff, 0x2f, 0xf0, 0xfe, 0x67, 0xf0, 0xfc, 0xf3, 0xf0, 0xfd,
  0xfb, 0xf0, 0xfb, 0xfd, 0xf0, 0xf3, 0xfc, 0xf0, 0xf4, 0x3e, 0xf0, 0xe4, 0xb3, 0x70, 0xee, 0x27,
  0x70, 0xef, 0xcf, 0x70, 0xef, 0x9f, 0x70, 0xef, 0x3f, 0x70, 0xee, 0x47, 0x70, 0xec, 0xd3, 0x70,
  0xf7, 0xc2, 0xf0, 0xf3, 0xfc, 0xf0, 0xfc, 0xf1, 0xf0, 0xfe, 0x07, 0xf0
};

const unsigned char temperature[] PROGMEM = {
  0xfe, 0x3f, 0xf0, 0xfc, 0xdf, 0xf0, 0xfd, 0xe8, 0xf0, 0xfd, 0xe9, 0xf0, 0xfd, 0xef, 0xf0, 0xfd,
  0x68, 0xf0, 0xfd, 0x6f, 0xf0, 0xfd, 0x68, 0xf0, 0xfd, 0x6f, 0xf0, 0xfd, 0x68, 0xf0, 0xfd, 0x69,
  0xf0, 0xfd, 0x6f, 0xf0, 0xf9, 0x67, 0xf0, 0xf2, 0x37, 0xf0, 0xf6, 0xd3, 0xf0, 0xf4, 0xd3, 0xf0,
  0xf2, 0x17, 0xf0, 0xfb, 0x37, 0xf0, 0xf9, 0xcf, 0xf0, 0xfe, 0x1f, 0xf0
};

const unsigned char clockl[] PROGMEM = {
  0xfe, 0x07, 0xf0, 0xf8, 0x01, 0xf0, 0xe0, 0x00, 0x70, 0xc0, 0x60, 0x30, 0xc0, 0x60, 0x30, 0x80,
  0x60, 0x10, 0x80, 0x60, 0x10, 0x00, 0x60, 0x00, 0x00, 0x60, 0x00, 0x00, 0x60, 0x00, 0x00, 0x60,
  0x00, 0x00, 0x18, 0x00, 0x00, 0x1c, 0x00, 0x80, 0x0c, 0x10, 0x80, 0x00, 0x10, 0xc0, 0x00, 0x30,
  0xc0, 0x00, 0x30, 0xe0, 0x00, 0x70, 0xf8, 0x01, 0xf0, 0xfe, 0x07, 0xf0
};
const unsigned char conect[] PROGMEM = {
  0xff, 0xff, 0xff, 0xfc, 0xe3, 0xf8, 0x7f, 0xfc, 0xdc, 0xf7, 0xbf, 0xfc, 0xbe, 0xef, 0xdf, 0xfc,
  0xbe, 0xee, 0xdf, 0xfc, 0xbe, 0xe9, 0xdf, 0xfc, 0xde, 0xf7, 0xbf, 0xfc, 0xc1, 0xf8, 0x7e, 0xec,
  0xfe, 0xfb, 0xfd, 0xf4, 0xfe, 0xfb, 0xfd, 0xb4, 0xff, 0x03, 0xf9, 0x74, 0xff, 0x3b, 0xe1, 0xe4,
  0xfe, 0xfd, 0x9e, 0x4c, 0xfe, 0xfe, 0x7f, 0xfc, 0xfe, 0xfe, 0xff, 0xfc, 0xfe, 0xfe, 0xff, 0xfc,
  0xfe, 0xfe, 0xff, 0xfc, 0xfe, 0xfc, 0xff, 0xfc, 0xff, 0x38, 0x7f, 0xfc, 0xff, 0x07, 0x3f, 0xfc,
  0xfe, 0xff, 0xdf, 0xfc, 0xe0, 0xff, 0xe7, 0xfc, 0xdc, 0xff, 0xf8, 0x0c, 0xba, 0xff, 0xfd, 0xec,
  0xa6, 0xff, 0xfd, 0xf4, 0xbe, 0xff, 0xfd, 0xf4, 0xde, 0xff, 0xfd, 0xf4, 0xe1, 0xff, 0xfc, 0xec,
  0xff, 0xff, 0xff, 0x1c, 0xff, 0xff, 0xff, 0xfc
};

const unsigned char loading[] PROGMEM = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x40, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00,
  0xa0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

const unsigned char icon_temperature[] PROGMEM = {
  0x00, 0x70, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x01, 0xfc, 0x00, 0x00,
  0x01, 0xfc, 0x00, 0x00, 0x3d, 0xfc, 0x00, 0x00, 0x01, 0xfc, 0x00, 0x00, 0x01, 0xfc, 0x00, 0x00,
  0x0d, 0xfc, 0x00, 0x00, 0x01, 0xfc, 0x7e, 0x70, 0x0d, 0xfc, 0x42, 0x58, 0x01, 0xfc, 0xc3, 0x70,
  0x39, 0xfc, 0xc0, 0x00, 0x3d, 0xdc, 0xc0, 0x00, 0x01, 0xdc, 0xc0, 0x00, 0x0d, 0xdc, 0xc0, 0x00,
  0x01, 0xdc, 0xc0, 0x00, 0x01, 0xdc, 0xc3, 0x00, 0x0d, 0xdc, 0x42, 0x00, 0x01, 0xdc, 0x3c, 0x00,
  0x3d, 0xdc, 0x00, 0x00, 0x01, 0xdc, 0x00, 0x00, 0x01, 0xdc, 0x00, 0x00, 0x01, 0xdc, 0x00, 0x00,
  0x01, 0x8e, 0x00, 0x00, 0x03, 0x8e, 0x00, 0x00, 0x03, 0x8e, 0x00, 0x00, 0x01, 0xfe, 0x00, 0x00,
  0x01, 0xfc, 0x00, 0x00, 0x00, 0x78, 0x00, 0x00
};


const unsigned char icon_reloj[] PROGMEM = {
  0x00, 0x1f, 0xe0, 0x00, 0x00, 0x7f, 0xf8, 0x00, 0x01, 0xff, 0xfe, 0x00, 0x03, 0xff, 0xff, 0x00,
  0x0f, 0xff, 0xff, 0xc0, 0x0f, 0xfc, 0xff, 0xc0, 0x1f, 0xfc, 0xff, 0xe0, 0x3f, 0xfc, 0xff, 0xf0,
  0x3f, 0xfc, 0xff, 0xf0, 0x7f, 0xfc, 0xff, 0xf8, 0x7f, 0xfc, 0xff, 0xf8, 0xff, 0xfc, 0xff, 0xfc,
  0xff, 0xfc, 0xff, 0xfc, 0xff, 0xfc, 0xff, 0xfc, 0xff, 0xfc, 0xff, 0xfc, 0xff, 0xfc, 0x7f, 0xfc,
  0xff, 0xfe, 0x3f, 0xfc, 0xff, 0xff, 0x1f, 0xfc, 0xff, 0xff, 0x8f, 0xfc, 0x7f, 0xff, 0xc7, 0xf8,
  0x7f, 0xff, 0xe7, 0xf8, 0x3f, 0xff, 0xff, 0xf8, 0x3f, 0xff, 0xff, 0xf0, 0x1f, 0xff, 0xff, 0xe0,
  0x0f, 0xff, 0xff, 0xe0, 0x0f, 0xff, 0xff, 0xc0, 0x03, 0xff, 0xff, 0x80, 0x01, 0xff, 0xfe, 0x00,
  0x00, 0x7f, 0xfc, 0x00, 0x00, 0x1f, 0xe0, 0x00
};
const unsigned char schedule[] PROGMEM = {
  0x18, 0x01, 0x80, 0x18, 0x01, 0x80, 0x7f, 0xff, 0xe0, 0xd8, 0x01, 0xb0, 0xd8, 0x01, 0xb0, 0xc0,
  0x00, 0x30, 0xff, 0xff, 0xf0, 0xc0, 0x00, 0x30, 0xc0, 0x00, 0x30, 0xd3, 0x6c, 0xb0, 0xd2, 0x64,
  0xb0, 0xc0, 0x00, 0x30, 0xd3, 0x6c, 0xb0, 0xd3, 0x6c, 0xb0, 0xc0, 0x00, 0x30, 0xd2, 0x64, 0x30,
  0xd3, 0x6c, 0x30, 0xc0, 0x00, 0x30, 0xff, 0xff, 0xf0, 0x7f, 0xff, 0xe0
};
const unsigned char satelite[] PROGMEM = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x00,
  0x00, 0x00, 0xf8, 0x00, 0x00, 0x00, 0x02, 0x7c, 0x00, 0x00, 0x00, 0x07, 0x3e, 0x00, 0x00, 0x00,
  0x03, 0x9c, 0x00, 0x00, 0x00, 0x19, 0xc8, 0x00, 0x00, 0x30, 0x3c, 0xe0, 0x00, 0x00, 0x7e, 0x3e,
  0x60, 0x00, 0x00, 0xff, 0x1f, 0x00, 0x00, 0x00, 0xff, 0x9f, 0x80, 0x00, 0x00, 0x7f, 0xf7, 0x00,
  0x00, 0x00, 0xff, 0xe2, 0x00, 0x00, 0x00, 0x7f, 0xf0, 0x00, 0x00, 0x00, 0x3f, 0xf8, 0x00, 0x00,
  0x00, 0x1f, 0xfc, 0x00, 0x00, 0x00, 0x0f, 0xfe, 0x00, 0x00, 0x00, 0xcf, 0xfc, 0x00, 0x00, 0x01,
  0xfb, 0xf8, 0x00, 0x00, 0x01, 0xf9, 0xf9, 0xfc, 0x00, 0x04, 0xfc, 0xe7, 0xfe, 0x00, 0x0e, 0x7c,
  0x47, 0xfe, 0x00, 0x07, 0x38, 0x0f, 0xfc, 0x00, 0x33, 0x90, 0x0f, 0xf8, 0x00, 0x79, 0xc0, 0x0f,
  0xf0, 0x00, 0x7c, 0xc0, 0x0f, 0xe0, 0x00, 0x3e, 0x00, 0x0f, 0xdc, 0x00, 0x1f, 0x00, 0x0f, 0x98,
  0x12, 0x0e, 0x00, 0x0f, 0x11, 0x12, 0x04, 0x00, 0x06, 0x01, 0x12, 0x00, 0x00, 0x00, 0x0e, 0x22,
  0x00, 0x00, 0x00, 0x00, 0x26, 0x00, 0x00, 0x00, 0x00, 0x44, 0x00, 0x00, 0x00, 0x01, 0x8c, 0x00,
  0x00, 0x00, 0x0e, 0x18, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x00, 0x00,
  0x00, 0x0f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00
};

const unsigned char velocimetro[] PROGMEM = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0x00, 0x00,
  0x01, 0xf7, 0xc0, 0x00, 0x03, 0xf7, 0xe0, 0x00, 0x03, 0xc1, 0xf0, 0x00, 0x0d, 0x00, 0x70, 0x00,
  0x1e, 0x00, 0x34, 0x00, 0x1c, 0x00, 0x2c, 0x00, 0x3c, 0x00, 0xde, 0x00, 0x38, 0x01, 0x8e, 0x00,
  0x38, 0x03, 0x0e, 0x00, 0x00, 0x0f, 0x0e, 0x00, 0x38, 0x1e, 0x0e, 0x00, 0x38, 0x1c, 0x0e, 0x00,
  0x3c, 0x08, 0x1e, 0x00, 0x1c, 0x00, 0x1c, 0x00, 0x1e, 0x00, 0x3c, 0x00, 0x0c, 0x3e, 0x18, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00
};

const unsigned char longitud[] PROGMEM = {
  0x00, 0x7f, 0x00, 0x00, 0x01, 0xeb, 0xc0, 0x00, 0x05, 0x2a, 0x50, 0x00, 0x0a, 0x49, 0x28, 0x00,
  0x12, 0x49, 0x24, 0x00, 0x24, 0x49, 0x12, 0x00, 0x24, 0x88, 0x90, 0x00, 0x48, 0x88, 0x89, 0x00,
  0x48, 0x88, 0x89, 0x00, 0x88, 0x88, 0x88, 0x80, 0x88, 0x88, 0x88, 0x80, 0x88, 0x88, 0x88, 0x80,
  0x88, 0x88, 0x88, 0x80, 0x88, 0x88, 0x88, 0x80, 0x88, 0x88, 0x88, 0x80, 0x88, 0x88, 0x88, 0x80,
  0x48, 0x88, 0x89, 0x00, 0x48, 0x88, 0x89, 0x00, 0x24, 0x88, 0x90, 0x00, 0x24, 0x49, 0x12, 0x00,
  0x12, 0x49, 0x24, 0x00, 0x0a, 0x49, 0x28, 0x00, 0x05, 0x2a, 0x50, 0x00, 0x01, 0xeb, 0xc0, 0x00,
  0x00, 0x7f, 0x00, 0x00
};

const unsigned char latitud[] PROGMEM = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00,
  0x00, 0xff, 0x80, 0x00, 0x03, 0xf7, 0xe0, 0x00, 0x07, 0x63, 0x30, 0x00, 0x06, 0x63, 0x10, 0x00,
  0x0c, 0x63, 0x18, 0x00, 0x0f, 0xff, 0xf8, 0x00, 0x1f, 0xc1, 0xfc, 0x00, 0x1c, 0x41, 0x9c, 0x00,
  0x3d, 0xdd, 0xde, 0x00, 0x1c, 0xc1, 0x9c, 0x00, 0x1f, 0xc1, 0xfc, 0x00, 0x0f, 0xff, 0xf8, 0x00,
  0x0c, 0x63, 0x18, 0x00, 0x04, 0x63, 0x10, 0x00, 0x06, 0x63, 0x30, 0x00, 0x03, 0xf7, 0xe0, 0x00,
  0x00, 0xff, 0x80, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00
};
const unsigned char check[] PROGMEM = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x01, 0xfc, 0x00, 0x00, 0x03, 0xfc,
  0x00, 0x00, 0x07, 0xf8, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x1f, 0xe0, 0x00, 0x00, 0x3f, 0xc0,
  0x00, 0x00, 0x7f, 0x80, 0x38, 0x00, 0xff, 0x00, 0x7c, 0x01, 0xfe, 0x00, 0xfe, 0x03, 0xfc, 0x00,
  0xff, 0x07, 0xf8, 0x00, 0x7f, 0x8f, 0xf0, 0x00, 0x3f, 0xff, 0xe0, 0x00, 0x1f, 0xff, 0xc0, 0x00,
  0x0f, 0xff, 0x80, 0x00, 0x07, 0xff, 0x00, 0x00, 0x03, 0xfe, 0x00, 0x00, 0x01, 0xfc, 0x00, 0x00,
  0x00, 0xf8, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

const unsigned char icon_sd[] PROGMEM = {
  0x01, 0xff, 0xff, 0xc0, 0x03, 0xfd, 0xdf, 0xe0, 0x03, 0x9d, 0xdc, 0xe0, 0x03, 0x9d, 0xdc, 0xe0,
  0x03, 0x9d, 0xdc, 0xe0, 0x03, 0x9d, 0xdf, 0xe0, 0x03, 0x9d, 0xdf, 0xe0, 0x03, 0xfd, 0xff, 0xe0,
  0x03, 0xff, 0xff, 0xe0, 0x07, 0xff, 0xff, 0xe0, 0x0f, 0xff, 0xff, 0xe0, 0x1f, 0xff, 0xff, 0xe0,
  0x1f, 0xff, 0xff, 0xe0, 0x1f, 0xff, 0xff, 0xe0, 0x1f, 0xff, 0xff, 0xe0, 0x1f, 0xff, 0xff, 0xe0,
  0x07, 0xff, 0xff, 0xe0, 0x07, 0xff, 0xff, 0xe0, 0x0f, 0xff, 0xff, 0xe0, 0x1f, 0xff, 0xff, 0xe0,
  0x1f, 0xff, 0xff, 0xe0, 0x1f, 0xff, 0xff, 0xe0, 0x1f, 0xfe, 0x18, 0xe0, 0x1f, 0xfc, 0xf8, 0x60,
  0x1f, 0xfd, 0x98, 0xe0, 0x1f, 0xfd, 0x8a, 0x60, 0x1f, 0xfc, 0x18, 0x60, 0x1f, 0xff, 0x39, 0xe0,
  0x1f, 0xff, 0xff, 0xe0, 0x0f, 0xff, 0xff, 0xc0
};
const unsigned char network[] PROGMEM = {
  0x00, 0x00, 0x00, 0x48, 0x90, 0x00, 0x04, 0x20, 0x00, 0x04, 0x40, 0x00, 0x48, 0x90, 0xc0, 0x38,
  0x60, 0x20, 0x04, 0x02, 0x80, 0x07, 0x82, 0x00, 0x04, 0x59, 0xe0, 0x08, 0x20, 0x00, 0x08, 0x20,
  0x00, 0x04, 0x40, 0x00, 0x07, 0x80, 0x00, 0x04, 0x08, 0x00, 0x48, 0x04, 0xc0, 0x04, 0x03, 0x20,
  0x24, 0x02, 0x00, 0x48, 0x02, 0x00, 0x30, 0x01, 0x20, 0x00, 0x00, 0x00
};

const unsigned char check_save[] PROGMEM = {
  // 'garrapata, 25x25px
  0x00, 0x7f, 0x00, 0x00, 0x01, 0xff, 0xc0, 0x00, 0x07, 0xff, 0xf0, 0x00, 0x0f, 0xc1, 0xf8, 0x00,
  0x1f, 0x00, 0x7c, 0x00, 0x3c, 0x00, 0x1e, 0x00, 0x38, 0x00, 0x0e, 0x00, 0x78, 0x00, 0x0f, 0x00,
  0x70, 0x00, 0xc7, 0x00, 0xf0, 0x01, 0xc7, 0x80, 0xe0, 0x03, 0xc3, 0x80, 0xe0, 0x87, 0x83, 0x80,
  0xe1, 0xcf, 0x03, 0x80, 0xe1, 0xfe, 0x03, 0x80, 0xe0, 0xfc, 0x03, 0x80, 0xf0, 0x78, 0x07, 0x80,
  0x70, 0x30, 0x07, 0x00, 0x78, 0x00, 0x0f, 0x00, 0x38, 0x00, 0x0e, 0x00, 0x3c, 0x00, 0x1e, 0x00,
  0x1f, 0x00, 0x7c, 0x00, 0x0f, 0xc1, 0xf8, 0x00, 0x07, 0xff, 0xf0, 0x00, 0x01, 0xff, 0xc0, 0x00,
  0x00, 0x7f, 0x00, 0x00
};
const unsigned char msg[] PROGMEM = {
  // 'enviar, 25x25px
  0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x0f, 0x80, 0x00, 0x00, 0x73, 0x00, 0x00, 0x03, 0x85, 0x00,
  0x00, 0x1e, 0x09, 0x00, 0x00, 0xf0, 0x12, 0x00, 0x07, 0x80, 0x22, 0x00, 0x3c, 0x00, 0x42, 0x00,
  0xe0, 0x00, 0x86, 0x00, 0x70, 0x01, 0x04, 0x00, 0x0e, 0x02, 0x04, 0x00, 0x03, 0x84, 0x0c, 0x00,
  0x00, 0x78, 0x08, 0x00, 0x00, 0x08, 0x08, 0x00, 0x08, 0x08, 0x18, 0x00, 0x10, 0x0c, 0x10, 0x00,
  0x20, 0x84, 0x10, 0x00, 0x41, 0x04, 0x30, 0x00, 0x82, 0x02, 0x20, 0x00, 0x04, 0x02, 0x20, 0x00,
  0x08, 0x21, 0x20, 0x00, 0x10, 0x41, 0x40, 0x00, 0x20, 0x81, 0xc0, 0x00, 0x41, 0x00, 0xc0, 0x00,
  0x82, 0x00, 0x80, 0x00
};

const unsigned char comprobar[] PROGMEM = {
  // 'buscar (1), 30x30px
  0x00, 0x01, 0xfc, 0x00, 0x00, 0x06, 0x03, 0x00, 0x00, 0x08, 0x00, 0x80, 0x00, 0x11, 0xfc, 0x20,
  0x00, 0x22, 0x03, 0x10, 0x00, 0x44, 0x00, 0x90, 0x00, 0x88, 0x70, 0x48, 0x00, 0x90, 0x50, 0x48,
  0x00, 0x90, 0x20, 0x24, 0x00, 0x20, 0x30, 0x24, 0x01, 0x20, 0x50, 0x24, 0x01, 0x20, 0x50, 0x24,
  0x01, 0x20, 0x50, 0x24, 0x00, 0x00, 0x50, 0x24, 0x00, 0x90, 0x50, 0x24, 0x00, 0x90, 0x50, 0x48,
  0x00, 0x48, 0x30, 0x88, 0x00, 0x44, 0x01, 0x10, 0x00, 0x63, 0x06, 0x20, 0x03, 0x90, 0x78, 0x40,
  0x06, 0xdc, 0x00, 0x80, 0x0c, 0x63, 0x07, 0x00, 0x00, 0x20, 0x70, 0x00, 0x30, 0x60, 0x00, 0x00,
  0x60, 0xc0, 0x00, 0x00, 0xc1, 0x80, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0x86, 0x00, 0x00, 0x00,
  0x8c, 0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 0x00
};
const unsigned char wrong[] PROGMEM = {
  // 'cancelar (1), 30x30px
  0x00, 0x1f, 0xe0, 0x00, 0x00, 0x7f, 0xf8, 0x00, 0x01, 0xe0, 0x1e, 0x00, 0x03, 0x80, 0x07, 0x00,
  0x0e, 0x00, 0x01, 0xc0, 0x0c, 0x00, 0x00, 0xc0, 0x18, 0x00, 0x00, 0x60, 0x30, 0x60, 0x18, 0x30,
  0x30, 0xf0, 0x3c, 0x30, 0x61, 0x98, 0x66, 0x18, 0x61, 0x8c, 0xc6, 0x18, 0xc0, 0xc7, 0x8c, 0x0c,
  0xc0, 0x63, 0x18, 0x0c, 0xc0, 0x30, 0x30, 0x0c, 0xc0, 0x18, 0x60, 0x0c, 0xc0, 0x18, 0x60, 0x0c,
  0xc0, 0x30, 0x30, 0x0c, 0xc0, 0x63, 0x18, 0x0c, 0xc0, 0xc7, 0x8c, 0x0c, 0x61, 0x8c, 0xc6, 0x18,
  0x61, 0x98, 0x66, 0x18, 0x30, 0xf0, 0x3c, 0x18, 0x30, 0x60, 0x18, 0x30, 0x18, 0x00, 0x00, 0x60,
  0x0c, 0x00, 0x00, 0xe0, 0x0e, 0x00, 0x01, 0xc0, 0x03, 0x80, 0x03, 0x80, 0x01, 0xe0, 0x1e, 0x00,
  0x00, 0x7f, 0xfc, 0x00, 0x00, 0x1f, 0xe0, 0x00
};

const unsigned char ready[] PROGMEM = {
  // 'garrapata (1), 30x30px
  0x00, 0x1f, 0xe0, 0x00, 0x00, 0x7f, 0xf8, 0x00, 0x01, 0xff, 0xfe, 0x00, 0x03, 0xff, 0xff, 0x00,
  0x0f, 0xff, 0xff, 0xc0, 0x0f, 0xff, 0xff, 0xc0, 0x1f, 0xff, 0xff, 0xe0, 0x3f, 0xff, 0xff, 0xf0,
  0x3f, 0xff, 0xff, 0xf0, 0x7f, 0xff, 0xf9, 0xf8, 0x7f, 0xff, 0xf0, 0xf8, 0xff, 0xff, 0xe0, 0xfc,
  0xff, 0xff, 0xc0, 0xfc, 0xff, 0xff, 0x81, 0xfc, 0xfc, 0x3f, 0x03, 0xfc, 0xfc, 0x1e, 0x07, 0xfc,
  0xfc, 0x0c, 0x0f, 0xfc, 0xfe, 0x00, 0x1f, 0xfc, 0xff, 0x00, 0x3f, 0xfc, 0x7f, 0x80, 0x7f, 0xf8,
  0x7f, 0xc0, 0xff, 0xf8, 0x3f, 0xe1, 0xff, 0xf8, 0x3f, 0xff, 0xff, 0xf0, 0x1f, 0xff, 0xff, 0xe0,
  0x0f, 0xff, 0xff, 0xe0, 0x0f, 0xff, 0xff, 0xc0, 0x03, 0xff, 0xff, 0x80, 0x01, 0xff, 0xfe, 0x00,
  0x00, 0x7f, 0xfc, 0x00, 0x00, 0x1f, 0xe0, 0x00
};

const unsigned char wifi[] PROGMEM = {
  // 'garrapata (1), 30x30px
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xfc, 0x00, 0x07, 0xff, 0xff, 0x80, 0x1f, 0xff, 0xff, 0xe0, 
	0x3f, 0x80, 0x07, 0xf0, 0xfc, 0x00, 0x00, 0xfc, 0xf0, 0x00, 0x00, 0x3c, 0xe0, 0x7f, 0xf8, 0x1c, 
	0x01, 0xff, 0xfe, 0x00, 0x03, 0xff, 0xff, 0x00, 0x07, 0xc0, 0x0f, 0x80, 0x07, 0x00, 0x03, 0x80, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xe0, 0x00, 0x00, 0x7f, 0xf8, 0x00, 0x00, 0x7f, 0xf8, 0x00, 
	0x00, 0x70, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x80, 0x00, 
	0x00, 0x07, 0x80, 0x00, 0x00, 0x07, 0x80, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};


const unsigned char icon_dust [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x80, 0x00, 0x00, 0x07, 0x80, 0x60, 0x00, 0x0f, 0x80, 0x70, 
	0x00, 0x0f, 0xc0, 0x20, 0x00, 0x0f, 0xc0, 0x00, 0x00, 0x03, 0x80, 0x00, 0x00, 0x00, 0x02, 0x00, 
	0x1a, 0x30, 0x0f, 0x80, 0x14, 0x20, 0x0f, 0x80, 0x28, 0x00, 0xff, 0x80, 0x2c, 0x01, 0x3f, 0x60, 
	0x10, 0x01, 0x7f, 0xf8, 0x0f, 0xf1, 0xff, 0xf8, 0x00, 0x00, 0x70, 0xf8, 0x3f, 0xe7, 0xf7, 0xf8, 
	0x00, 0x05, 0xef, 0xf0, 0x3f, 0x85, 0xff, 0xd0, 0x60, 0x05, 0xff, 0xd0, 0x58, 0x03, 0xfd, 0x90, 
	0x50, 0x00, 0x18, 0xe0, 0x48, 0x00, 0x00, 0x00, 0x3c, 0x40, 0x00, 0x00, 0x00, 0x60, 0x0e, 0x00, 
	0x00, 0x00, 0x0f, 0x80, 0x00, 0x02, 0x0f, 0x80, 0x00, 0x07, 0x1f, 0x80, 0x00, 0x07, 0x1f, 0x80, 
	0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00
};

static void SendConfirmationCallback(IOTHUB_CLIENT_CONFIRMATION_RESULT result)
{
  if (result == IOTHUB_CLIENT_CONFIRMATION_OK)
  {
    //receivtln("Enviar devolución de llamada de confirmación finalizada..");
  }
}
/*
  Función para que los registros tomados de los sensores se almacenen en la memoria SD.
  Argumentos:
   * fs: Instancia de la clase SD para el llamado de funciones propias para la lectura o escritura.
   * path: Ruta en la que reside el archivo .csv con los datos de cada nodo.
   * message: Contiene los datos a registrar en la microsd
   * type: Una variable que se utiliza para determinar si el mensaje que se va a escribir en la tarjeta proviene de otro nodo o son datos generados por el mismo nodo.
*/

void appendFile(fs::FS& fs, const char* path, const char* message, bool type) {
  //receivtln("se esta subiendo");
   //receivtln("Se esta adjuntando la infromación");
  File file = fs.open(path, FILE_APPEND);
  //FALSE - SUBIR - ENVIAR
  //TRUE - SUBIR - RECIBIR
  //receivt(path);
  //receivedtln("Abrir:");
  //receivedtln(file); //falso
  //receivedtln(type); //verdadero

  //verdadero verdadero que no tome el archivo y sea porque envia mensaje
  //No mostrar la imagen de fallo en la lectura de la sd cuando se tenga un mensaje entrante
  if (!file && type) {
    display.clearDisplay();
    display.setFont();
    display.setTextSize(1);
    display.setCursor(40, 10);
    display.setTextColor(WHITE);
    display.println("COMPRUEBE \n      SU SD");
    display.drawBitmap(60, 30, comprobar, 30, 30, WHITE);
    display.display();
    //delay(1000);
    wait_screen(3000);
    type = false;
  }
  String mensaje = "REGISTRO \n      EXITOSO";
  if (file && type) {
    file.println(message);
    display.clearDisplay();
    display.setTextSize(1);
    display.setCursor(0, 0);
    display.println("\t SUBIENDO ARCHIVOS \n A LA SD ");
    display.drawBitmap(50, 35, icon_sd, 30, 30, WHITE);
  //Estado de la carga ...
  //Listo - incorrecto
  //display.print("Uploading to SD card");    //display.drawRect(0,30,128,20,WHITE);
  //display.drawRect(0,50,128,20,WHITE);
  //display.drawRect(0,55,128,15,WHITE);
    display.print("Total space: ");
    display.print(SD.totalBytes() / (1024 * 1024));
    display.print("Mb");
    display.display();
    wait_screen(2000);
  //delay(3000);
    display.clearDisplay();
    display.setFont();
    display.setTextSize(1);
    display.drawBitmap(40, 20, ready, 30, 30, WHITE);
    display.setCursor(35, 5);
    display.println(mensaje);
    char size[1][20];
    sprintf(size[0], "Size file: %dKB", file.size() / 1024);
    display.setCursor(10, 55);
    display.println(size[0]);
    display.display();
    wait_screen(2000);
    //delay(1000);
    file.close();
    //Serial.println("Registro exitoso");
  } 
  
  
  flag = type;
  if (type) {
    sendMessage();
  }
}

/*
  Función que se ejecuta cuando existen cambios en la conexión a una red WiFi
  Argumentos:
   * ssid: Nombre del identificador de la red
   * password: Contraseña asignada para la autenticación ante la red.
*/
void onWifiSettingsChanged(std::string ssid, std::string password) {
  //Serial.print("WifiSetup: SSID = ");
  //Serial.print(ssid.c_str());
  //Serial.print(", Password = ");
  //Serial.println(password.c_str());
  WiFiMulti.addAP(ssid.c_str(), password.c_str());
}



void sendTelemetryToAzure(const char* metric, const char* value) {
    // Simulate sending telemetry data to Azure IoT Hub
    //Serial.printf("Sending telemetry to Azure: %s=%s\n", metric, value);
   
    // Create an HTTP client
    HTTPClient http;

    String url = String("https://") + azureIoTHubConnectionString + String("/") + endpoint + String("/messages/events?api-version=2020-03-13");
    String payload = String("{\"") + metric + "\":\"" + value + "\"}";
    String authorizationHeader = "SharedAccessSignature sr=iothubesp32makers.azure-devices.net&sig=YQBCiwMfdZJd8mfeLhAfB7vJFNm0weXf9og3RJyDZv0%3D&se=1699944755&skn=iothubowner";

    http.begin(url,root_ca);
    http.addHeader("Content-Type", "application/json");
    http.addHeader("Authorization", authorizationHeader);
    
    // Send the POST request with the payload
    int httpResponseCode = http.POST(payload);

    // Check for a successful request
    if (httpResponseCode > 0) {
        //Serial.printf("HTTP Response Code: %d\n", httpResponseCode);
    } else {
        //Serial.printf("HTTP Request failed: %s\n", http.errorToString(httpResponseCode).c_str());
    }
    // Close the connection
    http.end();

}
//¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡¡
//Función sin usar

String readFile(fs::FS& fs, const char* path) {
  display.clearDisplay();
  display.setFont();

  File file = fs.open(path);
  if (!file) {
    display.println("Falló al \n abrir el \n archivo");
  } else {
    display.println("Leyendo el \n archivo........");
  }
  //Serial.println("SDDDDD: ");
  display.display();
  //delay(2000);
  wait_screen(2000);
  String json = "";
  while (file.available()) {
    //Serial.write(file.read());
    //display.print(file.read());
    //char c = (char)file.read(); // Leer un byte y convertirlo en carácter
    json += String(file.read());  // Concatenar el carácter a la variable String
  }
  //Serial.println(json);
  //sprintf(buffer, "Hora: %02lu:%02lu:%02lu | Latitud: %.6f | Longitud: %.6f | Temperatura: %.2f°C | Humedad: %.2f%%")
  file.close();
  return json;
}

void setup() {
  Serial.begin(115200);
  pmsSerial.begin(9600);
  display.begin(SSD1306_SWITCHCAPVCC, OLED_ADDRESS);
  display.clearDisplay();
  //Codigo para mostrar por pantalla la conexión a wifi
  /*
  strcpy(data_gps,"0.0");
  for(int k=0;k<sizeof(buffer_gps)/sizeof(buffer_gps[0]);k++){
    sprintf(buffer_gps[k],"%s",data_gps);
    //Serial.print(buffer_gps[k]);
  }

  char* msg_red[2][3]={{"Conectando a la red","Dispositivo conectado","Datos subidos a Azure"},{"Conectando a la red..","    Dispositivo\n     Conectado","Datos subidos \n \t a Azure"}};
  char* msg_final_red=(char*)malloc(130);
  
    Se configura el modo estación (WIFI_STA) de la ESP32 para que actue como un cliente que se conecta a una red WiFi existente.
    Se realiza el intento de conexión y verifica si el proceso fue satisfactorio, en caso contrario reiteredamente intentará de nuevo buscar y conectar a la red con las credenciales especificadas.

  strcpy(msg_final_red,"Conectando a la red");
  //Serial.print("Connecting to WiFi ..");
  display.setTextColor(WHITE);
  display.setFont();
  //Serial.println("Conexión exitosa");
  WiFi.mode(WIFI_STA);
  sprintf(msg_final_red,"%s",msg_red[1][0]);
  //Serial.printf("%s",msg_red[0][0]);
  //Serial.println(WiFi.SSID());
  //Serial.println(WiFi.localIP());
  //Serial.println(WiFi.subnetMask());
    */
  if(!SD.begin(5)){
    //Serial.println("Card Mount Failed");
  }
  //Serial.println("1");
  uint8_t cardType = SD.cardType();
  if(cardType == CARD_NONE){
        //Serial.println("No se tiene una tarjeta insertada");
  }
  uint64_t cardSize = SD.cardSize() / (1024 * 1024);
  //Serial.printf("SD Tamaño: %lluMB\n", cardSize);
  //Serial.print(SD.numSectors());
  //Serial.println(ESP.getFreeHeap());
  //gadgetBle.begin();  
  ////Serial.println(gadgetBle.getDeviceIdString());
  mesh.setDebugMsgTypes(ERROR | STARTUP);  // set before init() so that you can see startup messages
  mesh.init(MESH_PREFIX, MESH_PASSWORD, &userScheduler, MESH_PORT);///implementar una opción para enviar los datos--finalizar la visibilidad como punto de acceso y terminar las conexiones existentes
  mesh.onReceive(&receivedCallback);
  mesh.onNewConnection(&newConnectionCallback);
  mesh.onChangedConnections(&changedConnectionCallback);
  mesh.onNodeTimeAdjusted(&nodeTimeAdjustedCallback);
  mesh.onNodeDelayReceived(&delayReceivedCallback);
  userScheduler.addTask(taskSendMessage);
  userScheduler.addTask(taskGetMessage);
  taskSendMessage.enable();
  taskGetMessage.enable();
  taskSendMessage.setInterval(1000);
  taskGetMessage.setInterval(1000);
  /*
    WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    //Serial.print(".");
    display.setTextSize(1);
    display.setCursor(0,5);
    display.printf("         Red     \n %s",ssid);
    display.drawBitmap(45,28,wifi, 25,25, WHITE);
    display.setCursor(35,51);
    display.println("Conectando...");
    display.display();
    delay(5000);
    display.clearDisplay();
  }
  /*
  /*
    Se configura inicialmente el nombre de la red, la clave y el puerto de comunicación
    Se relaciona las funciones que se deben ejecutar cuando se presenta alguna de las siguientes acciones:
    *Desconexión de un nodo (Cambios en la red)
    *Conexión de un nuevo nodo.
    El programador de tareas vincula una nueva tarea y la ejecutará segun lo programado.
  */
  //neogps.begin(9600, SERIAL_8N1, RXD2, TXD2);
  Wire.begin();
  dht.begin();
  /*
  Rtc.Begin(21, 22);
  //delay(3000);
  
  Rtc.SetIsRunning(true);
  RtcDateTime compiled = RtcDateTime(__DATE__, __TIME__);
  Rtc.SetSquareWavePin(DS3231SquareWavePin_ModeClock, true);
  Rtc.SetSquareWavePinClockFrequency(DS3231SquareWaveClock_1Hz);
  Rtc.ForceTemperatureCompensationUpdate(false);
  */
    if (! rtc.begin()) {
    //Serial.println("Couldn't find RTC");
    Serial.flush();
    while (1) delay(10);
  }

  if (rtc.lostPower()) {
    //Serial.println("RTC lost power, let's set the time!");
    // When time needs to be set on a new device, or after a power loss, the
    // following line sets the RTC to the date & time this sketch was compiled
    rtc.adjust(DateTime(F(__DATE__), F(__TIME__)));
    // This line sets the RTC with an explicit date & time, for example to set
    // January 21, 2014 at 3am you would call:
    // rtc.adjust(DateTime(2014, 1, 21, 3, 0, 0));
  }
  pinMode(33, INPUT);
  pinMode(34, INPUT);
  display.clearDisplay();
  display.invertDisplay(true);
  display.setFont(&FreeSerifBoldItalic9pt7b);
  display.setCursor(20,20);
  display.print("Conectado");
  display.drawBitmap(50,35,check,25,25,WHITE);
  display.display();
  wait_screen(3000);
  display.clearDisplay();
  display.setFont();
  
  //Status de cada uno de los

  /*
    Recopilar y registrar los datos
    Obteniendo información (Gif)
    Esto solo tardara unos segundos........
    Información capturada por lo modulos

    Esp32 conectada
    Red Wifi:  --colocar una etiqueta o prefijo con el numero  
    
    Un momento por favor
    Sincronizar datos en la nube (Enviar la info a varios nodos hasta que llegue al principal y que la cargue)
    Regresar
    */
}

/*
  Consulta los metodos que permiten capturar los registros tomados por cada sensor y los guarda en variables con un buffer especifico.
  Esta función permite ver los datos que se capturaron por medio de los sensores en el display montado en la protoboard.}
  Verifica si ya exite un archivo creado previamente y escribe la información en la tarjeta SD
*/

bool menu_show_data() {

  unsigned long currentMillis = millis();
  previousMillis = millis();
  long interval = 3000;
  int k = 5000;
  while (currentMillis - previousMillis < interval) {
    currentMillis = millis();
    display.clearDisplay();
    display.setFont();
    display.setTextColor(WHITE);
    display.setTextSize(1);
    display.drawCircle(67, 32, 8, WHITE);
    display.drawBitmap(50, 15, loading, 35, 35, WHITE);
    String ms = "Se esta recopilando     la informacion \n \n \n \n  Espere un momento. \n Faltan    segundos.....";
    display.setCursor(4, 4);
    display.println(ms);
    display.setCursor(55, 52);
    char str[20];
    sprintf(str, "%d", k / 1000);
    display.print(str);
    display.display();
    k = 5000 - (currentMillis - previousMillis);
  }
  status_menu=true;
  //Llamar las funciones de los datos...
  //RtcDateTime now = Rtc.GetDateTime();
  DateTime now = rtc.now();
  ////Serial.println(data_DHT_11());  //Append file o crear el archivo path*

  ////Serial.print(data_RTC_HW_084());

  //data_GPS_NEO6MV2();  // se queda buscando satelites..... apenas encuentre uno guarde los datos recibidos y salga del loop

  char set_data[2000];
  data_DHT_11();//revisar como se muestra la temperatura
  //display.ssd1306_command(SSD1306_SETCONTRAST);
  data_RTC_HW_084();
  send_data_PM2();
  data_GPS_NEO6MV2();
  String head = "Fecha;Hora;Temperatura_Reloj;Humedad;TemperaturaC;TemperaturaF;CalorF;CalorC;Longuitud;Latitud;Velocidad;Satelites;PM1.0;PM2.5;PM10;PM_ENV1.0;PM_ENV2.5;PM_ENV10.0;PM0.3um;PM0.5um;PM1um;PM2.5um;PM5um;PM10um\n";
  //Serial.print(set_data);
  //Ver si se visualizan en pantalla los datos
  //Serial.print("Edw2");
  //información SDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD
  //Serial.println(buffer_rtc);//Verificar la muestra de datos obtenido del sensor
  //Serial.println(buffer_dht);//Verificar la muestra de datos obtenido del sensor
  //Serial.println(buffer_final);
  //Serial.println(buffer_pm);

  const char* id = "/ESP_ID";
  char folder_name[50];
  strcpy(folder_name, id);
  String node_id = String(mesh.getNodeId());
  strcat(folder_name, node_id.c_str());

  //Serial.print("Folder_Name: ");
  //Serial.println(folder_name);
  
  ////Serial.println(SD.exists(folder_name));
  ////Serial.println(SD.open(folder_name));
  ////Serial.println(SD.open("/NuevaCarpeta"));
  ////Serial.println(SD.mkdir("/NuevaCarpeta"));

  //Verificar si previamente se ha creado una carpeta y, en caso de que no exista, crearla."  
  if (!SD.exists(folder_name)) {
    if(SD.mkdir(folder_name)){
        //Serial.println("Carpeta creada exitosamente");
    }  //longuitud
    else{
        //Serial.println("Ocurrió un error mientras se creaba la carpeta");
    }
  }
  //Validar si exite el archivo csv, si no existe añade el encabezado se crea un archivo por nodo
  snprintf(file_name,sizeof(file_name), "%s/data_%d.csv",folder_name, mesh.getNodeId());
  strcpy(set_data, "");
  //Serial.print("Ruta al archivo:");
  //Serial.println(file_name);

  snprintf(set_data + strlen(set_data), sizeof(set_data) - strlen(set_data), "%s%s", buffer_rtc, buffer_dht);
  ///Revisar poque se tiene la siguiente instrucción....
  for (int k = 0; k < sizeof(buffer_gps) / sizeof(buffer_gps[0]); k++) {
    snprintf(set_data + strlen(set_data), sizeof(set_data) - strlen(set_data), "%s", buffer_gps[k]); // REVISAR  SI ES S O C DE CHAR 1500 caracteres
  }
  //Revisar datos del gps
  //si no empieza el dht .begin tomar los datos
  strcat(set_data,buffer_pm.c_str());
  //que datos se estan concatenando
  //strcat(set_data,buffer_pm);/////////////////////////////////// PUNTO DE INTERRUPCIÓN

 //String hour = String(now.Month()) + "_" + String(now.Day()) + "_" + String(now.Year()) + "_" + String(now.Hour()) + "_" + String(now.Minute()) + "_" + String(now.Second());
  const char* const_file_name = file_name;

  data_send = String(set_data);
  appendFile(SD, const_file_name, data_send.c_str(), true);
  ////////////////////////////////////////////////////////////////////
  ////////////////////////////////////////////////////////////////////
  //Se transmite los datos recolectados del sensor pm,temperatura y humedad via bluetooth hacia la aplicación descargada en el telefono
  //send_data_sensirion_app();
  display.clearDisplay();

  display.drawBitmap(40,0,blue,50,50, WHITE);
  display.setFont();
  display.setTextSize(1);
  display.setCursor(0,47);
  display.print("ENVIANDO DATOS A LA \n     APP DE SENSIRION");
  display.display();
  wait_screen(2000);
  //Se valida si el dispositivo se encuentra conectado a cualquiera de las redes WIFI configuradas inicialmente
  /*
  while(WiFiMulti.run(5000) != WL_CONNECTED) {
      display.clearDisplay();
      display.setCursor(15,5);
      //Serial.println("Se perdio la conexión WIFI");
      //Serial.println("    Se esta conectando \n    nuevamente a la red...");
      display.drawBitmap(30,40,loading,30,30,WHITE);
      display.display();
      wait_screen(2000);
  }


  /*Se hace un cargue de datos hacia el servicio de IOT HUB especificando el ID de la ESP32 y adjuntando toda la data recopilada por los sensores para que despues
   sea enrutada hacia el punto de acceso en BlobStorage*/

/*
if (messageSending && (int)(millis() - send_interval_ms) >= INTERVAL)
    {
      char messagePayload[MESSAGE_MAX_LEN];
      //enviar los dato
      //const char *messageData = "{\"deviceId\":\"%s\", \"messageId\":%d, \"Temperature\":%f}"; //message format or the format template
      float humidity = dht.readHumidity();
      snprintf(messagePayload,MESSAGE_MAX_LEN,messageData, DEVICE_ID, messageCount++,H_T[0],H_T[1],buffer_data[0],buffer_data[1],num_satelites,lat,lon,speed);
      //snprintf(messagePayload,MESSAGE_MAX_LEN,messageData, DEVICE_ID, messageCount++,humidity);
      //snprintf(char *str, size_t size,  const char *format, ...)
      //snprintf(buffer,    maximum size, const char *format (i.e template), other arguments.....)
      //Serial.println(messagePayload);
      EVENT_INSTANCE* message = Esp32MQTTClient_Event_Generate(messagePayload, MESSAGE);
      Esp32MQTTClient_SendEventInstance(message);
      send_interval_ms = millis();
        //Serial.println("SALIOOOOOOOOOOOOOOOOOOO2222");
    }
  */
  display.clearDisplay();
  data_DHT_11_display(H_T[1], H_T[0], dht.convertCtoF(H_T[1]), dht.computeHeatIndex(H_T[1], H_T[0], false), dht.computeHeatIndex(dht.convertCtoF(H_T[1]), H_T[0], true));
  float t = Rtc.GetTemperature().AsCentiDegC() / 100;
  //Serial.print("Hora:");
  //Serial.println(String(now.month()) + "/" + String(now.day()) + "/" + String(now.year()));
  data_RTC_HW_084_display(String(now.month()) + "/" + String(now.day()) + "/" + String(now.year()), String(now.hour()) + ":" + String(now.minute()) + ":" + String(now.second()), String(t) + " C");
  display.clearDisplay();

  //Visualizacion sensor de polvo

  display.drawBitmap(10,10,icon_dust,30,25,WHITE); // imagen
  display.setTextColor(WHITE);
  display.setCursor(60,5); 
  display.println("SENSOR DE \n           POLVO PM");
  display.setCursor(60,20);
  display.printf("PM 10: %u\n  PM 25: %u\n  PM 100: %u\n  PM_env10: %u\n PM_env25: %u",values_PM[0],values_PM[1],values_PM[2],values_PM[3],values_PM[4]);
  //display.drawFastHLine(30, int16_t 0, int16_t w,WHITE);
  display.display();
  wait_screen(3000);

  //Visualización de los datos GPS 
  display.clearDisplay();
  display.setTextColor(WHITE);
  display.drawBitmap(20, 3, check, 30, 30, WHITE);
  display.setCursor(80, 22);
  display.setFont();
  char data_aux[10];
  int longitud = strlen(buffer_gps[3]);
  String miString = String(buffer_gps[3]).substring(0, longitud - 1);
  display.setCursor(5, 30);
  display.print("\nSATELITES DETECTADOS \n     EN LA ZONA");
  display.setCursor(80,15);
  display.setTextSize(2);
  display.print(miString);
  display.setTextSize(1);
  display.setCursor(5, 55);
  display.println("  Sincronizando...    ");
  display.display();
  wait_screen(3000);
  display.clearDisplay();
  display.setFont();
  display.drawBitmap(55,0,logo_ste,30,30,WHITE);
  display.setCursor(1,40);
  display.print("Latitud:");
  display.print(get_values(0));
  display.print(" Long:");
  display.println(get_values(1));
  display.print("Velocidad:");
  display.println(get_values(2));
  display.print("Num.satelites:");
  display.print(get_values(3));
  display.drawFastHLine(0,30,180,WHITE);
  display.display();
  wait_screen(3000);
  display.clearDisplay();
  return true; 
}

String get_values(int k){
  int longitud = strlen(buffer_gps[k]);
  return String(buffer_gps[k]).substring(0, longitud - 1);
}




void wait_screen(long interval) {
  unsigned long currentMillis = millis();
  previousMillis = millis();
  while (currentMillis - previousMillis < interval) {
    currentMillis = millis();
  }
}

void menu_main() {
  display.drawRect(0, 32, 128, 30, WHITE);
  display.fillRect(0, 32, 128, 30, WHITE);
  display.drawCircle(112, 45, 10, WHITE);
  display.setTextSize(1);
  display.println("SEMILLERO MAKERS");
  display.setCursor(2, 45);
  display.println("->Capturar datos");
  display.setCursor(2, 55);
  display.println("->Subir a la nube");
  display.drawBitmap(0, 0, UniversidadSergioArboleda, 128, 30, WHITE);
  display.drawBitmap(105, 38, logo, 20, 20, BLACK);
  button[0] = 0;
  button[1] = 0;
  button[2] = 0;
}


//////////////////////////////////////77
//////////////////////////////////////7
bool button_A[] = {false, false, false};
bool button_B[] = {true, false, false};

void loop() {
  //sendTelemetryToAzure("Temperature", "25.5"); En
  //send_data_sensirion_app();
  //mesh.onReceive(&receivedCallback);
  //char* sensors_Data[NUM_BUFFERS][BUFFER_SIZE];
  //Tengo que validar que sea en la ultima pos 2
  bool switch_tabs=(digitalRead(33)==HIGH || status_menu==true)?(menu_show_data()):(menu()); 
  //menu_main()
  if(digitalRead(34)==HIGH){
    status_menu=false;
  }
  mesh.update();
  /*
    if(button[0]==2 && button[1]==0 && button[2]==0){
      display.setFont();
      display.println("\t ACCIONES EN LA RED \t");
      display.drawFastVLine(10,0,64,WHITE);
      display.drawFastHLine(0,20,128,WHITE);
      display.drawFastHLine(0,40,128,WHITE);
      display.drawFastHLine(0,60,128,WHITE);
      display.println("1.  Transmitir datos");
      display.println("2.  Mensaje recibidos");
      display.println("3.  Reajustes en la red");
      display.println("4.  Nuevos dispositivos");
      display.display();
    }
    */
  //Ocultar y mostrar el menu principal, datos, guardado de datos y envio de datos(String-concatenar).....se muestra los
  //strcat (str,"strings ");
  wait_screen(4000);

  //MOSTRAR INFO DE QUE SE ESTA CARGANDO LOS DATOS
}
void Visualizacion_Serial() {  
  //Serial.println("DATOS GPS");
  if (gps.location.isValid() == 1) {
    //Serial.print("Lat: ");
    //Serial.println(gps.location.lat(),6);
    //Serial.print("Lng: ");
    //Serial.println(gps.location.lng(),6);
    //Serial.print("Speed: ");
    //Serial.println(gps.speed.kmph());
    //Serial.print("SAT:");
    //Serial.println(gps.satellites.value());
    //Serial.print("ALT:");
    //Serial.println(gps.altitude.meters(), 0);
    //Serial.print("Date: ");
    //Serial.print(gps.date.day()); //Serial.print("/");
    //Serial.print(gps.date.month()); //Serial.print("/");
    //Serial.println(gps.date.year());

    //Serial.print("Hour: ");
    //Serial.print(gps.time.hour()); //Serial.print(":");
    //Serial.print(gps.time.minute()); //Serial.print(":");
    //Serial.println(gps.time.second());
    //Serial.println("---------------------------");
  }
}


bool menu(){

  display.invertDisplay(false);
  display.setTextColor(SSD1306_WHITE);
  display.startscrollright(0x00, 0x0F);
  //delay(2000);
  display.stopscroll();
  display.setCursor(2, 33);  // posición más baja en la pantalla
  display.setTextColor(BLACK);
  //display.setFont(&FreeSerifBoldItalic9pt7b);
  display.drawRect(0, 32, 128, 30, WHITE);
  display.fillRect(0, 32, 128, 30, WHITE);
  display.drawCircle(112, 45, 10, WHITE);
  display.setTextSize(1);
  display.println("SEMILLERO MAKERS");
  display.setCursor(2, 45);
  display.println("->Capturar datos");
  display.setCursor(2, 55);
  display.println("->Enviar datos");
  display.drawBitmap(0, 0, UniversidadSergioArboleda, 128, 30, WHITE);
  display.drawBitmap(105, 38, logo, 20, 20, BLACK);
  display.display();
  wait_screen(2000);
  return true;
}


void menu_network() {
  display.clearDisplay();
  display.setFont(&FreeSerifBoldItalic9pt7b);
  display.setCursor(0, 60);
  display.print("\t RED MESH\t ");
  display.setCursor(40, 11);
  display.setFont();
  display.println("1.Transmitir información");
  display.setCursor(55, 20);
  display.drawFastHLine(0, 0, display.width(), WHITE);
  display.println("2.Ver mensajes entrantes");
  display.drawFastHLine(0, 0, display.width(), WHITE);
  display.display();
  // Pintar el menu y validar que opción escoigo
  if (digitalRead(33) == HIGH) {
    //enviar mensaje
    display.setCursor(30, 60);
    display.setFont(&FreeSerifBoldItalic9pt7b);
    display.print("Estableciendo \n conexión....");
    //delay(3000);
    display.clearDisplay();
    display.setCursor(30, 60);
    display.print("Enviando \n mediciones....");
    //delay(2000);
  }
  if (digitalRead(34) == HIGH) {
    //listar dispositivos
  }
  menu_main();
}




//Se inicalice la matriz cada vez que se recorra el loop[]

//Temperatura y humedad

void data_DHT_11() {
  H_T[0]=dht.readHumidity();
  H_T[1]=dht.readTemperature();
  //index=dht.computeHeatIndex(H_T[1], H_T[0],false);
  char numString[20];
  //Serial.print("Humedad:");
  //Serial.println(dtostrf(dht.readHumidity(), 6, 2, numString));
  //Serial.print("Temperatura:");
  //Serial.println(dht.readTemperature());
  if (isnan(H_T[0]) || isnan(H_T[1])) {
    //Serial.println("Error al leer el sensor DHT!");
    display.display();
  }
  //nombre del nodo - aleatorio de la hora
  sprintf(buffer_dht, "%2.2f;%2.1f;%3.2f;%3.2f;%3.2f;", H_T[0], H_T[1], dht.convertCtoF(H_T[1]), dht.computeHeatIndex(H_T[1], H_T[0], false), dht.computeHeatIndex(dht.convertCtoF(H_T[1]), H_T[0], true));
  //Serial.printf("Humedad: %2.2f, \nTemperatura(°C): %2.1f °C, \nTemperatura(°F): %3.2f °F, \nIndice de calor(°C): %3.2f °C,\nIndice de calor(°F): %3.2f °F", H_T[0], H_T[1], dht.convertCtoF(H_T[1]), dht.computeHeatIndex(H_T[1], H_T[0], false), dht.computeHeatIndex(dht.convertCtoF(H_T[1]), H_T[0], true));
  //Serial.print("\nBuffer dht: ");
  //Serial.println(buffer_dht);
  //snprintf(sensors_Data[0], BUFFER_SIZE, "hello world #%ld", value);

  //data_DHT_11_display(H_T[1], H_T[0], dht.convertCtoF(H_T[1]), dht.computeHeatIndex(H_T[1], H_T[0], false), dht.computeHeatIndex(dht.convertCtoF(H_T[1]), H_T[0], true));
  //display.clearDisplay();
  //  sprintf(buffer, "%02u/%02u/%04u %02u:%02u:%02u", now.Month(), now.Day(), now.Year(), now.Hour(), now.Minute(), now.Second());
  //sprintf(buffer, "Dato = %3d", numero);
  //snprintf (sensors_Data[0],BUFFER_SIZE, "hello world #%ld", value);
  //strcat (str,"strings ");
  //Matriz de strings que al final todos los concatenemos y podamos recorrerla y guardar el mensaje
}


//Visualizar los datos de la temperatura
void data_DHT_11_display(float t_c, float h, float t_f, float idx_c, float idx_f) {
  char buffer_data[5][100];
  float list_data_recolected[] = { t_c, t_f, h, idx_c, idx_f };
  String alias[5][2] = { { "Temp:", "C" }, { "Temp:", "F" }, { "Humedad:", "%" }, { "IndCalor:", "C" }, { "IndCalor:", "F" } };
  for (int j = 0; j < sizeof(alias) / sizeof(alias[0]); j++) {
    char* myString = (char*)malloc(100);
    sprintf(myString, "%s %2.2f %s", alias[j][0], list_data_recolected[j], alias[j][1]);
    //Serial.write(myString);
    strcpy(buffer_data[j], myString);
    free(myString);
  }
  
  display.setFont(&FreeSerifBoldItalic9pt7b);
  display.invertDisplay(false);
  display.setCursor(15, 10);
  display.println("Temperatura");
  display.drawBitmap(55, 30, icon_temperature, 30, 30, WHITE);
  display.display();
  //delay(1000);
  wait_screen(2000);
  display.clearDisplay();
  display.setFont();
  display.setCursor(0, 0);
  display.print("\t LISTADO DE DATOS \t ");
  display.setCursor(25, 11);
  display.println(buffer_data[0]);
  display.setCursor(25, 20);
  display.println(buffer_data[1]);
  display.drawBitmap(0, 10, temperature, 19, 20, WHITE);
  //display.drawLine(60, 19, 127,19, WHITE);
  display.drawRect(0, 10, 128, 20, WHITE);
  display.setCursor(25, 30);
  display.println(buffer_data[2]);
  display.setCursor(25, 40);
  display.println(buffer_data[3]);
  //display.drawLine(70, 19, 127,19, WHITE);
  display.drawRect(0, 29, 128, 20, WHITE);
  display.drawBitmap(0, 30, icon_humedity, 20, 20, WHITE);
  //display.write((byte)1);
  display.setCursor(25, 55);
  display.println(buffer_data[4]);
  display.setCursor(25, 65);
  display.drawRect(0, 48, 128, 20, WHITE);
  display.drawBitmap(0, 50, icon_hot, 20, 20, WHITE);
  //display.drawLine(80,39,128,39,WHITE);
  display.display();
  //delay(3000);
  wait_screen(3000);
}

//Temperatura c y k hora fecha

//Reloj
void data_RTC_HW_084() {
  DateTime now = rtc.now();
  sprintf(buffer_rtc, "%02u/%02u/%04u;%02u:%02u:%02u;%.3f;", now.month(), now.day(), now.year(), now.hour(), now.minute(), now.second(), rtc.getTemperature() / 100);
  //Serial.print("Buffer RTC: ");
  //Serial.println(buffer_rtc);
}


void data_RTC_HW_084_display(String fecha, String hora, String t) {
  String alias[3][2] = { { "Fecha:", fecha }, { "Hora:", hora }, { "Temp:", t } };
  for (int j = 0; j < sizeof(alias) / sizeof(alias[0]); j++) {
    char* myString = (char*)malloc(40);

    sprintf(myString, "%s %s", alias[j][0], alias[j][1]);
    //Serial.write(myString);
    strcpy(buffer_data[j], myString);
    free(myString);
  }
  //Serial.println(alias[0][1]);
  display.clearDisplay();
  display.setFont(&FreeSerifBoldItalic9pt7b);
  display.setCursor(15, 10);
  display.println("       Reloj");
  display.drawBitmap(55, 30, icon_reloj, 30, 30, WHITE);
  display.display();
  //delay(1000);
  wait_screen(1000);
  display.clearDisplay();
  display.setFont();
  display.setTextSize(1);
  display.setCursor(0, 0);
  display.print("\t LISTADO DE DATOS \t ");
  display.drawBitmap(20, 9, schedule, 19, 20, WHITE);
  display.drawBitmap(60, 9, clockl, 19, 20, WHITE);
  display.drawBitmap(100, 9, temperature, 19, 20, WHITE);
  //drawRoundRect (uint16_t x0, uint16_t y0, uint16_t w, uint16_t h, uint16_t radio, uint16_t color)
  display.drawRoundRect(19, 8, 22, 23, 2, WHITE);
  display.drawRoundRect(59, 8, 22, 23, 2, WHITE);
  display.drawRoundRect(99, 8, 22, 23, 2, WHITE);
  display.drawLine(0, 32, 128, 32, WHITE);
  display.setCursor(20, 35);
  display.print(buffer_data[0]);
  display.drawLine(0, 43, 128, 43, WHITE);
  display.setCursor(20, 46);
  display.println(buffer_data[1]);
  display.drawLine(0, 54, 128, 54, WHITE);
  display.setCursor(20, 56);
  display.println(buffer_data[2]);
  display.drawLine(0, 65, 128, 69, WHITE);
  /*
    display.setCursor(25,11);
    display.println(buffer_data[0]); 
    display.setCursor(25,20);
    display.println(buffer_data[1]); 
    //display.drawLine(60, 19, 127,19, WHITE);
    display.drawRect(0,10,128,20,WHITE);
    display.setCursor(25,30);
    display.println(buffer_data[2]); 
    display.setCursor(25,40);
    display.println(buffer_data[3]); 
    //display.drawLine(70, 19, 127,19, WHITE);
    display.drawRect(0,29,128,20,WHITE);
    display.drawBitmap(0,30,clockl,20,20,WHITE);
    //display.write((byte)1);
    display.setCursor(25,55);
    display.println(buffer_data[4]);
    display.setCursor(25,65);
    display.drawBitmap(0,50,temperature,20,20,WHITE);
    display.drawRect(0,48,128,20,WHITE);
    //display.drawLine(80,39,128,39,WHITE);
  */
  display.display();
  //delay(3000); edwinnnn
  wait_screen(3000);
}
void data_GPS_NEO6MV2() {
  Visualizacion_Serial();
  boolean newData = false;
  String search = ".";  
  for (unsigned long start = millis(); millis() - start < 1000;) {
      unsigned long time_flag=millis();
      while (true) {
        //Serial.println("");
        //si hay datos disponibles en el búfer del módulo GPS para ser leídos.
        //Serial.print("Bytes Entrada:");
        //Serial.print(neogps.available());
        //Serial.print("  Satelites:");
        //Serial.print(gps.satellites.value()); ///mostar la cantidad de datos
        //Serial.print("  Latitud:");
        //Serial.print(gps.location.lat());
        //Serial.print("  Longuitud:");
        //Serial.print(gps.location.lng());
        //Serial.print("  Tiempo:");
        //Serial.print(millis()-time_flag);

        if (gps.encode(neogps.read())) {
          newData = true;
        }
        if (gps.satellites.value() > 0 || millis()-time_flag>=5000) {
          //delay(2000);
          wait_screen(2000);
          //Serial.print("\nSatelites:");
          //Serial.println(gps.satellites.value());
          //Serial.print("Bytes Entrante:");
          //Serial.println(neogps.available());
          break;
        }
        
      }
    }

    if (newData == true) {
      newData = false;
      Visualizacion_Serial();
      lat = gps.location.lat();
      lon = gps.location.lng();
      speed = gps.speed.kmph();
      String variables[4][1] = { { String(roundf(lat * 100) / 100) }, { String(roundf(lon * 100) / 100) }, { String(roundf(speed * 100) / 100) }, { String(gps.satellites.value()) } };
      for (int k = 0; k < 4; k++) {
        char* myString = (char*)malloc(50);
        sprintf(myString, "%3.2f:", atof(variables[k][0].c_str()));
        strcpy(buffer_gps[k], myString);
        free(myString);
        strcat(buffer_final, buffer_gps[k]);
      }
    } else {
      char values_gps_default[]="0;";
      for(int k=0;k<sizeof(buffer_gps)/sizeof(buffer_gps[0]);k++){
        strcpy(buffer_gps[k],values_gps_default);
        strcat(buffer_final, buffer_gps[k]);
      }/// retorna con valores en cero
    }
    //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
}

void send_data_sensirion_app(){
    //Despues de enviados a traves de la red....
  gadgetBle.writePM1p0(values_PM[0]);
  gadgetBle.writePM2p5(values_PM[1]);
  gadgetBle.writePM10p0(values_PM[2]);
  gadgetBle.writeTemperature(H_T[1]);
  gadgetBle.writeHumidity(H_T[0]);
  gadgetBle.commit();
  char msg_prompt[]="Valores enviado a sensirion";
  //Serial.println("Enviando datos a sensirion");
  //Serial.printf("%s",msg_prompt);
  //Serial.printf("%u %u %u \n ",values_PM[0],values_PM[1],values_PM[2]);
  wait_screen(2000);
  gadgetBle.handleEvents();
}


boolean readPMSdata(Stream *s) {
  if (! s->available()) {
    return false;
  }
  if (s->peek() != 0x42) {
    s->read();
    return false;
  }
  if (s->available() < 32) {
    return false;
  } 
  uint8_t buffer[32];    
  uint16_t sum = 0;
  s->readBytes(buffer, 32);
  for (uint8_t i=0; i<30; i++) {
    sum += buffer[i];
  }
  uint16_t buffer_u16[15];
  for (uint8_t i=0; i<15; i++) {
    buffer_u16[i] = buffer[2 + i*2 + 1];
    buffer_u16[i] += (buffer[2 + i*2] << 8);
  }
  memcpy((void *)&data, (void *)buffer_u16, 30);
  if (sum != data.checksum) {
    //Serial.println("Checksum failure");
    return false;
  }   
  return true;
}

/*VALORES DEL PM*/

void send_data_PM2(){
  if (buffer_pm.length() > 0){
    buffer_pm="";
  }
  
  if (!readPMSdata(&pmsSerial)) {
    //Serial.println("Could not read from AQI");
    for(int f=0;f<sizeof(values_PM)/sizeof(values_PM[0]);f++){
      buffer_pm+=String(values_PM[f])+";";
    }
    //strcpy(buffer_pm,help.c_str());
    //Serial.println("Datos tomados deL PMS5003");
    //Serial.println(data.pm10_standard);
    //Serial.println(data.pm25_standard);
    //Serial.println(data.pm100_standard);
      // try again in a bit!
  }else{
    values_PM[0]=data.pm10_standard;
    values_PM[1]=data.pm25_standard;
    values_PM[2]=data.pm100_standard;
    values_PM[3]=data.pm10_env;
    values_PM[4]=data.pm25_env;
    values_PM[5]=data.pm100_env;
    values_PM[6]=data.particles_03um;
    values_PM[7]=data.particles_05um;
    values_PM[8]=data.particles_10um;
    values_PM[9]=data.particles_25um;
    values_PM[10]=data.particles_50um;
    values_PM[11]=data.particles_100um;
    for(int f=0;f<sizeof(values_PM)/sizeof(values_PM[0]);f++){
      char num[15]; // Crea un array para almacenar el número como cadena
      sprintf(num, "%d",values_PM[f]); 
      buffer_pm+=String(values_PM[f])+";";
    }
    // reading data was successful!
    //Serial.print("Buffer pm: ");
    //Serial.println(buffer_pm);
    //Serial.println();
    //Serial.println("---------------------------------------");
    //Serial.println("Concentration Units (standard)");
    //Serial.print("PM 1.0: "); //Serial.print(data.pm10_standard);
    //Serial.print("\t\tPM 2.5: "); //Serial.print(data.pm25_standard);
    //Serial.print("\t\tPM 10: "); //Serial.println(data.pm100_standard);
    //Serial.println("---------------------------------------");
    //Serial.println("Concentration Units (environmental)");
    //Serial.print("PM 1.0: "); //Serial.print(data.pm10_env);
    //Serial.print("\t\tPM 2.5: "); //Serial.print(data.pm25_env);
    //Serial.print("\t\tPM 10: "); //Serial.println(data.pm100_env);
    //Serial.println("---------------------------------------");
    //Serial.print("Particles > 0.3um / 0.1L air:"); //Serial.println(data.particles_03um);
    //Serial.print("Particles > 0.5um / 0.1L air:"); //Serial.println(data.particles_05um);
    //Serial.print("Particles > 1.0um / 0.1L air:"); //Serial.println(data.particles_10um);
    //Serial.print("Particles > 2.5um / 0.1L air:"); //Serial.println(data.particles_25um);
    //Serial.print("Particles > 5.0um / 0.1L air:"); //Serial.println(data.particles_50um);
    //Serial.print("Particles > 10.0 um / 0.1L air:"); //Serial.println(data.particles_100um);
    //Serial.println("---------------------------------------");
    //Serial.print("MUESTRADO DE LAS DATOS");
    //Serial.print(F("PM 1.0: ")); //Serial.print(values_PM[0]);
    //Serial.print(F("\t\tPM 2.5: ")); //Serial.print(values_PM[1]);
    //Serial.print(F("\t\tPM 10: ")); //Serial.println(values_PM[2]);
    wait_screen(3000);
  } 
  
}
  //buffer_pm lo que se incluye en lo que se envia
  //los esta mostrando
void receiveMessage(){
  mesh.update();
}

void sendMessage() {
  //Datos enviados a traves de la red, string
  //leer el contendio de la sd
  RtcDateTime now = Rtc.GetDateTime();
  if (flag) {
    Serial.printf("Mensaje enviado de %u msg=%s\n", mesh.getNodeId(), data_send.c_str());
    display.clearDisplay();
    display.setTextSize(1);
    display.setFont();
    display.setTextColor(WHITE);
    display.drawFastHLine(0, 5, 128, WHITE);
    display.setCursor(30, 10);
    display.println("Transmitiendo");
    display.setCursor(45, 25);
    display.println("datos");
    display.drawFastHLine(0, 35, 128, WHITE);
    display.drawBitmap(48, 43, msg, 25, 25, WHITE);
    display.display();
    wait_screen(2000);
    //delay(2000);
    //readFile(fs::FS& fs, const char* path); //devuelva un string en un buffer
    //datos enviados
    //char buffer[5000];
    // adjuntar la hora medinate un String
    //sprintf(buffer,"------------------%02lu:%02lu:%02lu Nodo: %u-------------------\n %s",now.Hour(),now.Minute(),now.Second(),mesh.getNodeId(),msgsend);
    //String cad=String(buffer);
    mesh.sendBroadcast(data_send);
    display.clearDisplay();
    display.setFont();
    display.setCursor(40, 40);
    display.print("Mensaje \n    Transmitido");
    display.drawBitmap(50, 10, message_icon, 30, 30, WHITE);  ///
    display.display();
    //delay(1000);
    wait_screen(2000);
    //Serial.print("Mensaje enviado:");
    //Serial.println(data_send);
    button[1] = 0;
  }
  flag = false;
  taskSendMessage.setInterval(random(TASK_SECOND * 1, TASK_SECOND * 5));
}

// Needed for painless library
void receivedCallback(uint32_t from, String& msg) {
  Serial.print("Mensaje Recibido: ");
  Serial.println(msg.c_str());
  String cad=msg.c_str();
  char name_folder[] = "/ESP_ID";
  char id[20];
  sprintf(id, "%lu", from);
  //CONCATENAR +=
  strcat(name_folder, id);
  //validar que se haya creado la carpeta setdata,nombre del archivo
  if (SD.exists(name_folder) == false) {
    SD.mkdir(name_folder);  //longuitud
  }
  String file_name = name_folder;
  file_name += "/data_" + String(from) + ".csv"; //Recibir información y adjuntar
  appendFile(SD, file_name.c_str() , msg.c_str(), false);
  wait_screen(4000);
  /*
    if(button[1]==2){
      display.clearDisplay();
      //Serial.printf("startHere: Received from %u msg=%s\n", from, msg.c_str());
      display.setCursor(0,50);
      display.print("Nodo ");
      display.print(from);
      display.drawFastHLine(10,0,128,WHITE);
      display.print("* Temp:");
      display.println(args[3]);
      display.println("* Humedad:");
      display.println(args[4]);
      display.print("* Lat:");
      display.println(args[1]);
      display.print("| Lon:");
      display.println(args[2]);
      display.print("* Hora");
      display.println(args[0]);
      display.display();
      //delay(10000);
      button[0]=2;
    }
    */
  //Serial.printf("startHere: Received from %u msg=%s\n", from, msg.c_str());
}

void newConnectionCallback(uint32_t nodeId) {
  Serial.printf("--> Nuevo dispositivo conectado a la red mesh, nodeId = %u\n", nodeId);
}

void changedConnectionCallback() {
  Serial.printf("Existen cambios en la conformación de la red\n");
}

void nodeTimeAdjustedCallback(int32_t offset) {
  Serial.printf("Se ajusta el tiempo de sincronización %u. Offset = %d\n", mesh.getNodeTime(), offset);
}
void delayReceivedCallback(uint32_t from, int32_t delay) {
  Serial.printf("Delay to node %u is %d us\n", from, delay);
}
